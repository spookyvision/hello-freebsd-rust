/* automatically generated by rust-bindgen 0.57.0 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __XSI_VISIBLE: u32 = 700;
pub const __BSD_VISIBLE: u32 = 1;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __EXT1_VISIBLE: u32 = 1;
pub const __CHAR_BIT: u32 = 8;
pub const __SCHAR_MAX: u32 = 127;
pub const __SCHAR_MIN: i32 = -128;
pub const __UCHAR_MAX: u32 = 255;
pub const __USHRT_MAX: u32 = 65535;
pub const __SHRT_MAX: u32 = 32767;
pub const __SHRT_MIN: i32 = -32768;
pub const __UINT_MAX: u32 = 4294967295;
pub const __INT_MAX: u32 = 2147483647;
pub const __INT_MIN: i32 = -2147483648;
pub const __ULONG_MAX: i32 = -1;
pub const __LONG_MAX: u64 = 9223372036854775807;
pub const __LONG_MIN: i64 = -9223372036854775808;
pub const __ULLONG_MAX: i32 = -1;
pub const __LLONG_MAX: u64 = 9223372036854775807;
pub const __LLONG_MIN: i64 = -9223372036854775808;
pub const __SSIZE_MAX: u64 = 9223372036854775807;
pub const __SIZE_T_MAX: i32 = -1;
pub const __OFF_MAX: u64 = 9223372036854775807;
pub const __OFF_MIN: i64 = -9223372036854775808;
pub const __UQUAD_MAX: i32 = -1;
pub const __QUAD_MAX: u64 = 9223372036854775807;
pub const __QUAD_MIN: i64 = -9223372036854775808;
pub const __LONG_BIT: u32 = 64;
pub const __WORD_BIT: u32 = 32;
pub const __MINSIGSTKSZ: u32 = 2048;
pub const __WCHAR_MIN: i32 = -2147483648;
pub const __WCHAR_MAX: u32 = 2147483647;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const __bool_true_false_are_defined: u32 = 1;
pub const false_: u32 = 0;
pub const true_: u32 = 1;
pub const _SIG_WORDS: u32 = 4;
pub const _SIG_MAXSIG: u32 = 128;
pub const FD_SETSIZE: u32 = 1024;
pub const MDT_DEPEND: u32 = 1;
pub const MDT_MODULE: u32 = 2;
pub const MDT_VERSION: u32 = 3;
pub const MDT_PNP_INFO: u32 = 4;
pub const MDT_STRUCT_VERSION: u32 = 1;
pub const MDT_SETNAME: &'static [u8; 16usize] = b"modmetadata_set\0";
pub const MAXMODNAME: u32 = 32;
pub const MPLOCKED: &'static [u8; 8usize] = b"lock ; \0";
pub const OFFSETOF_MONITORBUF: u32 = 256;
pub const CR4_PGE: u32 = 128;
pub const INVPCID_ADDR: u32 = 0;
pub const INVPCID_CTX: u32 = 1;
pub const INVPCID_CTXGLOB: u32 = 2;
pub const INVPCID_ALLCTX: u32 = 3;
pub const MSR_FSBASE: u32 = 3221225728;
pub const MSR_GSBASE: u32 = 3221225729;
pub const CALLOUT_LOCAL_ALLOC: u32 = 1;
pub const CALLOUT_ACTIVE: u32 = 2;
pub const CALLOUT_PENDING: u32 = 4;
pub const CALLOUT_MPSAFE: u32 = 8;
pub const CALLOUT_RETURNUNLOCKED: u32 = 16;
pub const CALLOUT_SHAREDLOCK: u32 = 32;
pub const CALLOUT_DFRMIGRATION: u32 = 64;
pub const CALLOUT_PROCESSED: u32 = 128;
pub const CALLOUT_DIRECT: u32 = 256;
pub const C_DIRECT_EXEC: u32 = 1;
pub const C_PRELBITS: u32 = 7;
pub const C_PRELRANGE: u32 = 127;
pub const C_HARDCLOCK: u32 = 256;
pub const C_ABSOLUTE: u32 = 512;
pub const C_PRECALC: u32 = 1024;
pub const C_CATCH: u32 = 2048;
pub const CS_DRAIN: u32 = 1;
pub const CS_EXECUTING: u32 = 2;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -2147483648;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 2147483647;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 4294967295;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i64 = -9223372036854775808;
pub const SIG_ATOMIC_MAX: u64 = 9223372036854775807;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const __WORDSIZE: u32 = 64;
pub const WCHAR_MIN: i32 = -2147483648;
pub const WCHAR_MAX: u32 = 2147483647;
pub const RSIZE_MAX: i32 = -1;
pub const BSD: u32 = 199506;
pub const BSD4_3: u32 = 1;
pub const BSD4_4: u32 = 1;
pub const __FreeBSD_version: u32 = 1202000;
pub const P_OSREL_SIGWAIT: u32 = 700000;
pub const P_OSREL_SIGSEGV: u32 = 700004;
pub const P_OSREL_MAP_ANON: u32 = 800104;
pub const P_OSREL_MAP_FSTRICT: u32 = 1100036;
pub const P_OSREL_SHUTDOWN_ENOTCONN: u32 = 1100077;
pub const P_OSREL_MAP_GUARD: u32 = 1200035;
pub const P_OSREL_WRFSBASE: u32 = 1200041;
pub const P_OSREL_CK_CYLGRP: u32 = 1200046;
pub const P_OSREL_VMTOTAL64: u32 = 1200054;
pub const ARG_MAX: u32 = 524288;
pub const CHILD_MAX: u32 = 40;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 1023;
pub const OPEN_MAX: u32 = 64;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const IOV_MAX: u32 = 1024;
pub const MAXCOMLEN: u32 = 19;
pub const MAXINTERP: u32 = 1024;
pub const MAXLOGNAME: u32 = 33;
pub const MAXUPRC: u32 = 40;
pub const NCARGS: u32 = 524288;
pub const NGROUPS: u32 = 1024;
pub const NOFILE: u32 = 64;
pub const NOGROUP: u32 = 65535;
pub const MAXHOSTNAMELEN: u32 = 256;
pub const SPECNAMELEN: u32 = 63;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const EOPNOTSUPP: u32 = 45;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EIDRM: u32 = 82;
pub const ENOMSG: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const ECANCELED: u32 = 85;
pub const EILSEQ: u32 = 86;
pub const ENOATTR: u32 = 87;
pub const EDOOFUS: u32 = 88;
pub const EBADMSG: u32 = 89;
pub const EMULTIHOP: u32 = 90;
pub const ENOLINK: u32 = 91;
pub const EPROTO: u32 = 92;
pub const ENOTCAPABLE: u32 = 93;
pub const ECAPMODE: u32 = 94;
pub const ENOTRECOVERABLE: u32 = 95;
pub const EOWNERDEAD: u32 = 96;
pub const EINTEGRITY: u32 = 97;
pub const ELAST: u32 = 97;
pub const ERESTART: i32 = -1;
pub const EJUSTRETURN: i32 = -2;
pub const ENOIOCTL: i32 = -3;
pub const EDIRIOCTL: i32 = -4;
pub const ERELOOKUP: i32 = -5;
pub const DST_NONE: u32 = 0;
pub const DST_USA: u32 = 1;
pub const DST_AUST: u32 = 2;
pub const DST_WET: u32 = 3;
pub const DST_MET: u32 = 4;
pub const DST_EET: u32 = 5;
pub const DST_CAN: u32 = 6;
pub const SBT_MAX: u64 = 9223372036854775807;
pub const ITIMER_REAL: u32 = 0;
pub const ITIMER_VIRTUAL: u32 = 1;
pub const ITIMER_PROF: u32 = 2;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_VIRTUAL: u32 = 1;
pub const CLOCK_PROF: u32 = 2;
pub const CLOCK_MONOTONIC: u32 = 4;
pub const CLOCK_UPTIME: u32 = 5;
pub const CLOCK_UPTIME_PRECISE: u32 = 7;
pub const CLOCK_UPTIME_FAST: u32 = 8;
pub const CLOCK_REALTIME_PRECISE: u32 = 9;
pub const CLOCK_REALTIME_FAST: u32 = 10;
pub const CLOCK_MONOTONIC_PRECISE: u32 = 11;
pub const CLOCK_MONOTONIC_FAST: u32 = 12;
pub const CLOCK_SECOND: u32 = 13;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 14;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 15;
pub const TIMER_RELTIME: u32 = 0;
pub const TIMER_ABSTIME: u32 = 1;
pub const CPUCLOCK_WHICH_PID: u32 = 0;
pub const CPUCLOCK_WHICH_TID: u32 = 1;
pub const TC_DEFAULTPERC: u32 = 5;
pub const PRI_ITHD: u32 = 1;
pub const PRI_REALTIME: u32 = 2;
pub const PRI_TIMESHARE: u32 = 3;
pub const PRI_IDLE: u32 = 4;
pub const PRI_FIFO_BIT: u32 = 8;
pub const PRI_FIFO: u32 = 10;
pub const PRI_MIN: u32 = 0;
pub const PRI_MAX: u32 = 255;
pub const PRI_MIN_ITHD: u32 = 0;
pub const PI_REALTIME: u32 = 0;
pub const PI_AV: u32 = 4;
pub const PI_NET: u32 = 8;
pub const PI_DISK: u32 = 12;
pub const PI_TTY: u32 = 16;
pub const PI_DULL: u32 = 20;
pub const PI_SOFT: u32 = 24;
pub const PRI_MIN_REALTIME: u32 = 48;
pub const PRI_MIN_KERN: u32 = 80;
pub const PSWP: u32 = 80;
pub const PVM: u32 = 84;
pub const PINOD: u32 = 88;
pub const PRIBIO: u32 = 92;
pub const PVFS: u32 = 96;
pub const PZERO: u32 = 100;
pub const PSOCK: u32 = 104;
pub const PWAIT: u32 = 108;
pub const PLOCK: u32 = 112;
pub const PPAUSE: u32 = 116;
pub const PRI_MIN_TIMESHARE: u32 = 120;
pub const PUSER: u32 = 120;
pub const PRI_MIN_IDLE: u32 = 224;
pub const PRI_MAX_IDLE: u32 = 255;
pub const PRI_USER: i32 = -2;
pub const PRI_UNCHANGED: i32 = -1;
pub const FALSE: u32 = 0;
pub const TRUE: u32 = 1;
pub const MACHINE: &'static [u8; 6usize] = b"amd64\0";
pub const MACHINE_ARCH: &'static [u8; 6usize] = b"amd64\0";
pub const MACHINE_ARCH32: &'static [u8; 5usize] = b"i386\0";
pub const MAXCPU: u32 = 256;
pub const MAXMEMDOM: u32 = 8;
pub const CACHE_LINE_SHIFT: u32 = 6;
pub const CACHE_LINE_SIZE: u32 = 64;
pub const NPTEPGSHIFT: u32 = 9;
pub const PAGE_SHIFT: u32 = 12;
pub const PAGE_SIZE: u32 = 4096;
pub const PAGE_MASK: u32 = 4095;
pub const NPDEPGSHIFT: u32 = 9;
pub const PDRSHIFT: u32 = 21;
pub const NBPDR: u32 = 2097152;
pub const PDRMASK: u32 = 2097151;
pub const NPDPEPGSHIFT: u32 = 9;
pub const PDPSHIFT: u32 = 30;
pub const NBPDP: u32 = 1073741824;
pub const PDPMASK: u32 = 1073741823;
pub const NPML4EPGSHIFT: u32 = 9;
pub const PML4SHIFT: u32 = 39;
pub const NBPML4: u64 = 549755813888;
pub const PML4MASK: u64 = 549755813887;
pub const MAXPAGESIZES: u32 = 3;
pub const IOPAGES: u32 = 2;
pub const IOPERM_BITMAP_SIZE: u32 = 8193;
pub const KSTACK_PAGES: u32 = 4;
pub const KSTACK_GUARD_PAGES: u32 = 1;
pub const DEV_BSHIFT: u32 = 9;
pub const DEV_BSIZE: u32 = 512;
pub const BLKDEV_IOSIZE: u32 = 4096;
pub const DFLTPHYS: u32 = 65536;
pub const MAXPHYS: u32 = 131072;
pub const MAXDUMPPGS: u32 = 16;
pub const MSIZE: u32 = 256;
pub const MCLSHIFT: u32 = 11;
pub const MCLBYTES: u32 = 2048;
pub const MJUMPAGESIZE: u32 = 4096;
pub const MJUM9BYTES: u32 = 9216;
pub const MJUM16BYTES: u32 = 16384;
pub const PRIMASK: u32 = 255;
pub const PCATCH: u32 = 256;
pub const PDROP: u32 = 512;
pub const NZERO: u32 = 0;
pub const NBBY: u32 = 8;
pub const CMASK: u32 = 18;
pub const MAXBSIZE: u32 = 65536;
pub const MAXBCACHEBUF: u32 = 65536;
pub const BKVASIZE: u32 = 16384;
pub const BKVAMASK: u32 = 16383;
pub const MAXPATHLEN: u32 = 1024;
pub const MAXSYMLINKS: u32 = 32;
pub const FSHIFT: u32 = 11;
pub const FSCALE: u32 = 2048;
pub const CPU_SETSIZE: u32 = 256;
pub const CPU_MAXSIZE: u32 = 256;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_THREAD: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIMIT_SBSIZE: u32 = 9;
pub const RLIMIT_VMEM: u32 = 10;
pub const RLIMIT_AS: u32 = 10;
pub const RLIMIT_NPTS: u32 = 11;
pub const RLIMIT_SWAP: u32 = 12;
pub const RLIMIT_KQUEUES: u32 = 13;
pub const RLIMIT_UMTXP: u32 = 14;
pub const RLIM_NLIMITS: u32 = 15;
pub const CP_USER: u32 = 0;
pub const CP_NICE: u32 = 1;
pub const CP_SYS: u32 = 2;
pub const CP_INTR: u32 = 3;
pub const CP_IDLE: u32 = 4;
pub const CPUSTATES: u32 = 5;
pub const PC_PTI_STACK_SZ: u32 = 16;
pub const PC_DBREG_CMD_NONE: u32 = 0;
pub const PC_DBREG_CMD_LOAD: u32 = 1;
pub const DPCPU_SETNAME: &'static [u8; 9usize] = b"set_pcpu\0";
pub const DPCPU_SYMPREFIX: &'static [u8; 12usize] = b"pcpu_entry_\0";
pub const DPCPU_MODMIN: u32 = 2048;
pub const UMA_PCPU_ALLOC_SIZE: u32 = 4096;
pub const HASH_NOWAIT: u32 = 1;
pub const HASH_WAITOK: u32 = 2;
pub const HD_COLUMN_MASK: u32 = 255;
pub const HD_DELIM_MASK: u32 = 65280;
pub const HD_OMIT_COUNT: u32 = 65536;
pub const HD_OMIT_HEX: u32 = 131072;
pub const HD_OMIT_CHARS: u32 = 262144;
pub const GETENV_UNSIGNED: u32 = 0;
pub const GETENV_SIGNED: u32 = 1;
pub const LIBKERN_LEN_BCD2BIN: u32 = 154;
pub const LIBKERN_LEN_BIN2BCD: u32 = 100;
pub const LIBKERN_LEN_HEX2ASCII: u32 = 36;
pub const ARC4_ENTR_NONE: u32 = 0;
pub const ARC4_ENTR_HAVE: u32 = 1;
pub const ARC4_ENTR_SEED: u32 = 2;
pub const FNM_NOMATCH: u32 = 1;
pub const FNM_NOESCAPE: u32 = 1;
pub const FNM_PATHNAME: u32 = 2;
pub const FNM_PERIOD: u32 = 4;
pub const FNM_LEADING_DIR: u32 = 8;
pub const FNM_CASEFOLD: u32 = 16;
pub const FNM_IGNORECASE: u32 = 16;
pub const FNM_FILE_NAME: u32 = 2;
pub const TS_ENTER: u32 = 0;
pub const TS_EXIT: u32 = 1;
pub const TS_THREAD: u32 = 2;
pub const TS_EVENT: u32 = 3;
pub const KTR_GEN: u32 = 1;
pub const KTR_NET: u32 = 2;
pub const KTR_DEV: u32 = 4;
pub const KTR_LOCK: u32 = 8;
pub const KTR_SMP: u32 = 16;
pub const KTR_SUBSYS: u32 = 32;
pub const KTR_PMAP: u32 = 64;
pub const KTR_MALLOC: u32 = 128;
pub const KTR_TRAP: u32 = 256;
pub const KTR_INTR: u32 = 512;
pub const KTR_SIG: u32 = 1024;
pub const KTR_SPARE2: u32 = 2048;
pub const KTR_PROC: u32 = 4096;
pub const KTR_SYSC: u32 = 8192;
pub const KTR_INIT: u32 = 16384;
pub const KTR_SPARE3: u32 = 32768;
pub const KTR_SPARE4: u32 = 65536;
pub const KTR_EVH: u32 = 131072;
pub const KTR_VFS: u32 = 262144;
pub const KTR_VOP: u32 = 524288;
pub const KTR_VM: u32 = 1048576;
pub const KTR_INET: u32 = 2097152;
pub const KTR_RUNQ: u32 = 4194304;
pub const KTR_SPARE5: u32 = 8388608;
pub const KTR_UMA: u32 = 16777216;
pub const KTR_CALLOUT: u32 = 33554432;
pub const KTR_GEOM: u32 = 67108864;
pub const KTR_BUSDMA: u32 = 134217728;
pub const KTR_INET6: u32 = 268435456;
pub const KTR_SCHED: u32 = 536870912;
pub const KTR_BUF: u32 = 1073741824;
pub const KTR_PTRACE: u32 = 2147483648;
pub const KTR_ALL: u32 = 4294967295;
pub const KTR_COMPILE: u32 = 0;
pub const LC_SLEEPLOCK: u32 = 1;
pub const LC_SPINLOCK: u32 = 2;
pub const LC_SLEEPABLE: u32 = 4;
pub const LC_RECURSABLE: u32 = 8;
pub const LC_UPGRADABLE: u32 = 16;
pub const LO_CLASSFLAGS: u32 = 65535;
pub const LO_INITIALIZED: u32 = 65536;
pub const LO_WITNESS: u32 = 131072;
pub const LO_QUIET: u32 = 262144;
pub const LO_RECURSABLE: u32 = 524288;
pub const LO_SLEEPABLE: u32 = 1048576;
pub const LO_UPGRADABLE: u32 = 2097152;
pub const LO_DUPOK: u32 = 4194304;
pub const LO_IS_VNODE: u32 = 8388608;
pub const LO_CLASSMASK: u32 = 251658240;
pub const LO_NOPROFILE: u32 = 268435456;
pub const LO_NEW: u32 = 536870912;
pub const LO_CLASSSHIFT: u32 = 24;
pub const LOCK_CLASS_MAX: u32 = 15;
pub const LOP_NEWORDER: u32 = 1;
pub const LOP_QUIET: u32 = 2;
pub const LOP_TRYLOCK: u32 = 4;
pub const LOP_EXCLUSIVE: u32 = 8;
pub const LOP_DUPOK: u32 = 16;
pub const LA_MASKASSERT: u32 = 255;
pub const LA_UNLOCKED: u32 = 0;
pub const LA_LOCKED: u32 = 1;
pub const LA_SLOCKED: u32 = 2;
pub const LA_XLOCKED: u32 = 4;
pub const LA_RECURSED: u32 = 8;
pub const LA_NOTRECURSED: u32 = 16;
pub const LOCK_DEBUG: u32 = 1;
pub const KTR_VERSION: u32 = 2;
pub const KTR_PARMS: u32 = 6;
pub const KTR_ATTR_LINKED: &'static [u8; 14usize] = b"linkedto:\"%s\"\0";
pub const LOCKSTAT_WRITER: u32 = 0;
pub const LOCKSTAT_READER: u32 = 1;
pub const MTX_DEF: u32 = 0;
pub const MTX_SPIN: u32 = 1;
pub const MTX_RECURSE: u32 = 4;
pub const MTX_NOWITNESS: u32 = 8;
pub const MTX_NOPROFILE: u32 = 32;
pub const MTX_NEW: u32 = 64;
pub const MTX_QUIET: u32 = 2;
pub const MTX_DUPOK: u32 = 16;
pub const MTX_UNOWNED: u32 = 0;
pub const MTX_RECURSED: u32 = 1;
pub const MTX_CONTESTED: u32 = 2;
pub const MTX_DESTROYED: u32 = 4;
pub const MTX_FLAGMASK: u32 = 7;
pub const MTX_NETWORK_LOCK: &'static [u8; 15usize] = b"network driver\0";
pub const EHE_DEAD_PRIORITY: i32 = -1;
pub const EVENTHANDLER_PRI_FIRST: u32 = 0;
pub const EVENTHANDLER_PRI_ANY: u32 = 10000;
pub const EVENTHANDLER_PRI_LAST: u32 = 20000;
pub const SHUTDOWN_PRI_FIRST: u32 = 0;
pub const SHUTDOWN_PRI_DEFAULT: u32 = 10000;
pub const SHUTDOWN_PRI_LAST: u32 = 20000;
pub const LOWMEM_PRI_DEFAULT: u32 = 0;
pub const SI_ETERNAL: u32 = 1;
pub const SI_ALIAS: u32 = 2;
pub const SI_NAMED: u32 = 4;
pub const SI_UNUSED1: u32 = 8;
pub const SI_CHILD: u32 = 16;
pub const SI_DUMPDEV: u32 = 128;
pub const SI_CLONELIST: u32 = 512;
pub const SI_UNMAPPED: u32 = 1024;
pub const SI_NOSPLIT: u32 = 2048;
pub const D_TAPE: u32 = 1;
pub const D_DISK: u32 = 2;
pub const D_TTY: u32 = 4;
pub const D_MEM: u32 = 8;
pub const D_TYPEMASK: u32 = 65535;
pub const D_TRACKCLOSE: u32 = 524288;
pub const D_MMAP_ANON: u32 = 1048576;
pub const D_NEEDGIANT: u32 = 4194304;
pub const D_NEEDMINOR: u32 = 8388608;
pub const D_VERSION_00: u32 = 536942950;
pub const D_VERSION_01: u32 = 386080773;
pub const D_VERSION_02: u32 = 671358985;
pub const D_VERSION_03: u32 = 387063817;
pub const D_VERSION: u32 = 387063817;
pub const D_INIT: u32 = 2147483648;
pub const CLONE_UNITMASK: u32 = 1048575;
pub const CLONE_FLAG0: u32 = 1048576;
pub const MAKEDEV_REF: u32 = 1;
pub const MAKEDEV_WHTOUT: u32 = 2;
pub const MAKEDEV_NOWAIT: u32 = 4;
pub const MAKEDEV_WAITOK: u32 = 8;
pub const MAKEDEV_ETERNAL: u32 = 16;
pub const MAKEDEV_CHECKNAME: u32 = 32;
pub const MAKEDEV_ETERNAL_KLD: u32 = 0;
pub const UID_ROOT: u32 = 0;
pub const UID_BIN: u32 = 3;
pub const UID_UUCP: u32 = 66;
pub const UID_NOBODY: u32 = 65534;
pub const GID_WHEEL: u32 = 0;
pub const GID_KMEM: u32 = 2;
pub const GID_TTY: u32 = 4;
pub const GID_OPERATOR: u32 = 5;
pub const GID_BIN: u32 = 7;
pub const GID_GAMES: u32 = 13;
pub const GID_VIDEO: u32 = 44;
pub const GID_DIALER: u32 = 68;
pub const GID_NOGROUP: u32 = 65533;
pub const GID_NOBODY: u32 = 65534;
pub const UIO_MAXIOV: u32 = 1024;
pub const M_NOWAIT: u32 = 1;
pub const M_WAITOK: u32 = 2;
pub const M_ZERO: u32 = 256;
pub const M_NOVM: u32 = 512;
pub const M_USE_RESERVE: u32 = 1024;
pub const M_NODUMP: u32 = 2048;
pub const M_FIRSTFIT: u32 = 4096;
pub const M_BESTFIT: u32 = 8192;
pub const M_EXEC: u32 = 16384;
pub const M_NEXTFIT: u32 = 32768;
pub const M_MAGIC: u32 = 877983977;
pub const DTMALLOC_PROBE_MALLOC: u32 = 0;
pub const DTMALLOC_PROBE_FREE: u32 = 1;
pub const DTMALLOC_PROBE_MAX: u32 = 2;
pub const MALLOC_TYPE_STREAM_VERSION: u32 = 1;
pub const MALLOC_MAX_NAME: u32 = 32;
pub const _POSIX_ADVISORY_INFO: u32 = 200112;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200112;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 1;
pub const _POSIX_CLOCK_SELECTION: i32 = -1;
pub const _POSIX_CPUTIME: u32 = 200112;
pub const _POSIX_FSYNC: u32 = 200112;
pub const _POSIX_IPV6: u32 = 0;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_MAPPED_FILES: u32 = 200112;
pub const _POSIX_MEMLOCK: i32 = -1;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200112;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200112;
pub const _POSIX_MESSAGE_PASSING: u32 = 200112;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: i32 = -1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 0;
pub const _POSIX_RAW_SOCKETS: u32 = 200112;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200112;
pub const _POSIX_SEMAPHORES: u32 = 200112;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200112;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_SYNCHRONIZED_IO: i32 = -1;
pub const _POSIX_TIMEOUTS: u32 = 200112;
pub const _POSIX_TIMERS: u32 = 200112;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_VDISABLE: u32 = 255;
pub const _XOPEN_SHM: u32 = 1;
pub const _XOPEN_STREAMS: i32 = -1;
pub const _POSIX_VERSION: u32 = 200112;
pub const F_OK: u32 = 0;
pub const X_OK: u32 = 1;
pub const W_OK: u32 = 2;
pub const R_OK: u32 = 4;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const SEEK_DATA: u32 = 3;
pub const SEEK_HOLE: u32 = 4;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _PC_LINK_MAX: u32 = 1;
pub const _PC_MAX_CANON: u32 = 2;
pub const _PC_MAX_INPUT: u32 = 3;
pub const _PC_NAME_MAX: u32 = 4;
pub const _PC_PATH_MAX: u32 = 5;
pub const _PC_PIPE_BUF: u32 = 6;
pub const _PC_CHOWN_RESTRICTED: u32 = 7;
pub const _PC_NO_TRUNC: u32 = 8;
pub const _PC_VDISABLE: u32 = 9;
pub const _PC_ASYNC_IO: u32 = 53;
pub const _PC_PRIO_IO: u32 = 54;
pub const _PC_SYNC_IO: u32 = 55;
pub const _PC_ALLOC_SIZE_MIN: u32 = 10;
pub const _PC_FILESIZEBITS: u32 = 12;
pub const _PC_REC_INCR_XFER_SIZE: u32 = 14;
pub const _PC_REC_MAX_XFER_SIZE: u32 = 15;
pub const _PC_REC_MIN_XFER_SIZE: u32 = 16;
pub const _PC_REC_XFER_ALIGN: u32 = 17;
pub const _PC_SYMLINK_MAX: u32 = 18;
pub const _PC_ACL_EXTENDED: u32 = 59;
pub const _PC_ACL_PATH_MAX: u32 = 60;
pub const _PC_CAP_PRESENT: u32 = 61;
pub const _PC_INF_PRESENT: u32 = 62;
pub const _PC_MAC_PRESENT: u32 = 63;
pub const _PC_ACL_NFS4: u32 = 64;
pub const _PC_MIN_HOLE_SIZE: u32 = 21;
pub const RFNAMEG: u32 = 1;
pub const RFENVG: u32 = 2;
pub const RFFDG: u32 = 4;
pub const RFNOTEG: u32 = 8;
pub const RFPROC: u32 = 16;
pub const RFMEM: u32 = 32;
pub const RFNOWAIT: u32 = 64;
pub const RFCNAMEG: u32 = 1024;
pub const RFCENVG: u32 = 2048;
pub const RFCFDG: u32 = 4096;
pub const RFTHREAD: u32 = 8192;
pub const RFSIGSHARE: u32 = 16384;
pub const RFLINUXTHPN: u32 = 65536;
pub const RFSTOPPED: u32 = 131072;
pub const RFHIGHPID: u32 = 262144;
pub const RFTSIGZMB: u32 = 524288;
pub const RFTSIGSHIFT: u32 = 20;
pub const RFTSIGMASK: u32 = 255;
pub const RFPROCDESC: u32 = 268435456;
pub const RFPPWAIT: u32 = 2147483648;
pub const RFSPAWN: u32 = 2147483648;
pub const RFFLAGS: u32 = 2416930932;
pub const RFKERNELONLY: u32 = 268828672;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_long;
pub type __uint64_t = cty::c_ulong;
pub type __clock_t = __int32_t;
pub type __critical_t = __int64_t;
pub type __double_t = f64;
pub type __float_t = f32;
pub type __intfptr_t = __int64_t;
pub type __intptr_t = __int64_t;
pub type __intmax_t = __int64_t;
pub type __int_fast8_t = __int32_t;
pub type __int_fast16_t = __int32_t;
pub type __int_fast32_t = __int32_t;
pub type __int_fast64_t = __int64_t;
pub type __int_least8_t = __int8_t;
pub type __int_least16_t = __int16_t;
pub type __int_least32_t = __int32_t;
pub type __int_least64_t = __int64_t;
pub type __ptrdiff_t = __int64_t;
pub type __register_t = __int64_t;
pub type __segsz_t = __int64_t;
pub type __size_t = __uint64_t;
pub type __ssize_t = __int64_t;
pub type __time_t = __int64_t;
pub type __uintfptr_t = __uint64_t;
pub type __uintptr_t = __uint64_t;
pub type __uintmax_t = __uint64_t;
pub type __uint_fast8_t = __uint32_t;
pub type __uint_fast16_t = __uint32_t;
pub type __uint_fast32_t = __uint32_t;
pub type __uint_fast64_t = __uint64_t;
pub type __uint_least8_t = __uint8_t;
pub type __uint_least16_t = __uint16_t;
pub type __uint_least32_t = __uint32_t;
pub type __uint_least64_t = __uint64_t;
pub type __u_register_t = __uint64_t;
pub type __vm_offset_t = __uint64_t;
pub type __vm_paddr_t = __uint64_t;
pub type __vm_size_t = __uint64_t;
pub type ___wchar_t = cty::c_int;
pub type __blksize_t = __int32_t;
pub type __blkcnt_t = __int64_t;
pub type __clockid_t = __int32_t;
pub type __fflags_t = __uint32_t;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint64_t;
pub type __gid_t = __uint32_t;
pub type __id_t = __int64_t;
pub type __ino_t = __uint64_t;
pub type __key_t = cty::c_long;
pub type __lwpid_t = __int32_t;
pub type __mode_t = __uint16_t;
pub type __accmode_t = cty::c_int;
pub type __nl_item = cty::c_int;
pub type __nlink_t = __uint64_t;
pub type __off_t = __int64_t;
pub type __off64_t = __int64_t;
pub type __pid_t = __int32_t;
pub type __rlim_t = __int64_t;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __suseconds_t = cty::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __timer {
    _unused: [u8; 0],
}
pub type __timer_t = *mut __timer;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mq {
    _unused: [u8; 0],
}
pub type __mqd_t = *mut __mq;
pub type __uid_t = __uint32_t;
pub type __useconds_t = cty::c_uint;
pub type __cpuwhich_t = cty::c_int;
pub type __cpulevel_t = cty::c_int;
pub type __cpusetid_t = cty::c_int;
pub type __daddr_t = __int64_t;
pub type __ct_rune_t = cty::c_int;
pub type __rune_t = __ct_rune_t;
pub type __wint_t = __ct_rune_t;
pub type __char16_t = __uint_least16_t;
pub type __char32_t = __uint_least32_t;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __max_align_t {
    pub __max_align1: cty::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __max_align2: u128,
}
#[test]
fn bindgen_test_layout___max_align_t() {
    assert_eq!(
        ::core::mem::size_of::<__max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(__max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(__max_align_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__max_align_t>())).__max_align1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__max_align_t),
            "::",
            stringify!(__max_align1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__max_align_t>())).__max_align2 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__max_align_t),
            "::",
            stringify!(__max_align2)
        )
    );
}
pub type __dev_t = __uint64_t;
pub type __fixpt_t = __uint32_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [cty::c_char; 128usize],
    pub _mbstateL: __int64_t,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __rman_res_t = __uintmax_t;
pub type __va_list = __builtin_va_list;
pub type __gnuc_va_list = __va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_mutex_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlockattr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrier_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_spinlock {
    _unused: [u8; 0],
}
pub type pthread_t = *mut pthread;
pub type pthread_attr_t = *mut pthread_attr;
pub type pthread_mutex_t = *mut pthread_mutex;
pub type pthread_mutexattr_t = *mut pthread_mutex_attr;
pub type pthread_cond_t = *mut pthread_cond;
pub type pthread_condattr_t = *mut pthread_cond_attr;
pub type pthread_key_t = cty::c_int;
pub type pthread_once_t = pthread_once;
pub type pthread_rwlock_t = *mut pthread_rwlock;
pub type pthread_rwlockattr_t = *mut pthread_rwlockattr;
pub type pthread_barrier_t = *mut pthread_barrier;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_barrierattr {
    _unused: [u8; 0],
}
pub type pthread_barrierattr_t = *mut pthread_barrierattr;
pub type pthread_spinlock_t = *mut pthread_spinlock;
pub type pthread_addr_t = *mut cty::c_void;
pub type pthread_startroutine_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void) -> *mut cty::c_void>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_once {
    pub state: cty::c_int,
    pub mutex: pthread_mutex_t,
}
#[test]
fn bindgen_test_layout_pthread_once() {
    assert_eq!(
        ::core::mem::size_of::<pthread_once>(),
        16usize,
        concat!("Size of: ", stringify!(pthread_once))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_once>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_once))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_once>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_once>())).mutex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once),
            "::",
            stringify!(mutex)
        )
    );
}
pub type u_char = cty::c_uchar;
pub type u_short = cty::c_ushort;
pub type u_int = cty::c_uint;
pub type u_long = cty::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type u_quad_t = __uint64_t;
pub type quad_t = __int64_t;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut cty::c_char;
pub type c_caddr_t = *const cty::c_char;
pub type blksize_t = __blksize_t;
pub type cpuwhich_t = __cpuwhich_t;
pub type cpulevel_t = __cpulevel_t;
pub type cpusetid_t = __cpusetid_t;
pub type blkcnt_t = __blkcnt_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type critical_t = __critical_t;
pub type daddr_t = __daddr_t;
pub type dev_t = __dev_t;
pub type fflags_t = __fflags_t;
pub type fixpt_t = __fixpt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type gid_t = __gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type key_t = __key_t;
pub type lwpid_t = __lwpid_t;
pub type mode_t = __mode_t;
pub type accmode_t = __accmode_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type off64_t = __off64_t;
pub type pid_t = __pid_t;
pub type register_t = __register_t;
pub type rlim_t = __rlim_t;
pub type sbintime_t = __int64_t;
pub type segsz_t = __segsz_t;
pub type size_t = __size_t;
pub type ssize_t = __ssize_t;
pub type suseconds_t = __suseconds_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type mqd_t = __mqd_t;
pub type u_register_t = __u_register_t;
pub type uid_t = __uid_t;
pub type useconds_t = __useconds_t;
pub type cap_ioctl_t = cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cap_rights {
    _unused: [u8; 0],
}
pub type cap_rights_t = cap_rights;
pub type kvaddr_t = __uint64_t;
pub type ksize_t = __uint64_t;
pub type vm_offset_t = __vm_offset_t;
pub type vm_ooffset_t = __uint64_t;
pub type vm_paddr_t = __vm_paddr_t;
pub type vm_pindex_t = __uint64_t;
pub type vm_size_t = __vm_size_t;
pub type rman_res_t = __rman_res_t;
pub type boolean_t = cty::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct device {
    _unused: [u8; 0],
}
pub type device_t = *mut device;
pub type intfptr_t = __intfptr_t;
pub type intrmask_t = __uint32_t;
pub type uintfptr_t = __uintfptr_t;
pub type uoff_t = __uint64_t;
pub type vm_memattr_t = cty::c_char;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_page {
    _unused: [u8; 0],
}
pub type vm_page_t = *mut vm_page;
pub type bool_ = bool;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset {
    pub __bits: [__uint32_t; 4usize],
}
#[test]
fn bindgen_test_layout___sigset() {
    assert_eq!(
        ::core::mem::size_of::<__sigset>(),
        16usize,
        concat!("Size of: ", stringify!(__sigset))
    );
    assert_eq!(
        ::core::mem::align_of::<__sigset>(),
        4usize,
        concat!("Alignment of ", stringify!(__sigset))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sigset>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset),
            "::",
            stringify!(__bits)
        )
    );
}
pub type __sigset_t = __sigset;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: cty::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::core::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::core::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type __fd_mask = cty::c_ulong;
pub type fd_mask = __fd_mask;
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::core::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub const modeventtype_MOD_LOAD: modeventtype = 0;
pub const modeventtype_MOD_UNLOAD: modeventtype = 1;
pub const modeventtype_MOD_SHUTDOWN: modeventtype = 2;
pub const modeventtype_MOD_QUIESCE: modeventtype = 3;
pub type modeventtype = cty::c_uint;
pub use self::modeventtype as modeventtype_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct module {
    _unused: [u8; 0],
}
pub type module_t = *mut module;
pub type modeventhand_t = ::core::option::Option<
    unsafe extern "C" fn(arg1: module_t, arg2: cty::c_int, arg3: *mut cty::c_void) -> cty::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct moduledata {
    pub name: *const cty::c_char,
    pub evhand: modeventhand_t,
    pub priv_: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_moduledata() {
    assert_eq!(
        ::core::mem::size_of::<moduledata>(),
        24usize,
        concat!("Size of: ", stringify!(moduledata))
    );
    assert_eq!(
        ::core::mem::align_of::<moduledata>(),
        8usize,
        concat!("Alignment of ", stringify!(moduledata))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<moduledata>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(moduledata),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<moduledata>())).evhand as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(moduledata),
            "::",
            stringify!(evhand)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<moduledata>())).priv_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(moduledata),
            "::",
            stringify!(priv_)
        )
    );
}
pub type moduledata_t = moduledata;
#[repr(C)]
#[derive(Copy, Clone)]
pub union modspecific {
    pub intval: cty::c_int,
    pub uintval: u_int,
    pub longval: cty::c_long,
    pub ulongval: u_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_modspecific() {
    assert_eq!(
        ::core::mem::size_of::<modspecific>(),
        8usize,
        concat!("Size of: ", stringify!(modspecific))
    );
    assert_eq!(
        ::core::mem::align_of::<modspecific>(),
        8usize,
        concat!("Alignment of ", stringify!(modspecific))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<modspecific>())).intval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(modspecific),
            "::",
            stringify!(intval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<modspecific>())).uintval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(modspecific),
            "::",
            stringify!(uintval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<modspecific>())).longval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(modspecific),
            "::",
            stringify!(longval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<modspecific>())).ulongval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(modspecific),
            "::",
            stringify!(ulongval)
        )
    );
}
pub type modspecific_t = modspecific;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_depend {
    pub md_ver_minimum: cty::c_int,
    pub md_ver_preferred: cty::c_int,
    pub md_ver_maximum: cty::c_int,
}
#[test]
fn bindgen_test_layout_mod_depend() {
    assert_eq!(
        ::core::mem::size_of::<mod_depend>(),
        12usize,
        concat!("Size of: ", stringify!(mod_depend))
    );
    assert_eq!(
        ::core::mem::align_of::<mod_depend>(),
        4usize,
        concat!("Alignment of ", stringify!(mod_depend))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_depend>())).md_ver_minimum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_depend),
            "::",
            stringify!(md_ver_minimum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_depend>())).md_ver_preferred as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_depend),
            "::",
            stringify!(md_ver_preferred)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_depend>())).md_ver_maximum as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_depend),
            "::",
            stringify!(md_ver_maximum)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_version {
    pub mv_version: cty::c_int,
}
#[test]
fn bindgen_test_layout_mod_version() {
    assert_eq!(
        ::core::mem::size_of::<mod_version>(),
        4usize,
        concat!("Size of: ", stringify!(mod_version))
    );
    assert_eq!(
        ::core::mem::align_of::<mod_version>(),
        4usize,
        concat!("Alignment of ", stringify!(mod_version))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_version>())).mv_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_version),
            "::",
            stringify!(mv_version)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_metadata {
    pub md_version: cty::c_int,
    pub md_type: cty::c_int,
    pub md_data: *const cty::c_void,
    pub md_cval: *const cty::c_char,
}
#[test]
fn bindgen_test_layout_mod_metadata() {
    assert_eq!(
        ::core::mem::size_of::<mod_metadata>(),
        24usize,
        concat!("Size of: ", stringify!(mod_metadata))
    );
    assert_eq!(
        ::core::mem::align_of::<mod_metadata>(),
        8usize,
        concat!("Alignment of ", stringify!(mod_metadata))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_metadata>())).md_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_metadata),
            "::",
            stringify!(md_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_metadata>())).md_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_metadata),
            "::",
            stringify!(md_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_metadata>())).md_data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_metadata),
            "::",
            stringify!(md_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_metadata>())).md_cval as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_metadata),
            "::",
            stringify!(md_cval)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mod_pnp_match_info {
    pub descr: *const cty::c_char,
    pub bus: *const cty::c_char,
    pub table: *const cty::c_void,
    pub entry_len: cty::c_int,
    pub num_entry: cty::c_int,
}
#[test]
fn bindgen_test_layout_mod_pnp_match_info() {
    assert_eq!(
        ::core::mem::size_of::<mod_pnp_match_info>(),
        32usize,
        concat!("Size of: ", stringify!(mod_pnp_match_info))
    );
    assert_eq!(
        ::core::mem::align_of::<mod_pnp_match_info>(),
        8usize,
        concat!("Alignment of ", stringify!(mod_pnp_match_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_pnp_match_info>())).descr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_pnp_match_info),
            "::",
            stringify!(descr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_pnp_match_info>())).bus as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_pnp_match_info),
            "::",
            stringify!(bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_pnp_match_info>())).table as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_pnp_match_info),
            "::",
            stringify!(table)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_pnp_match_info>())).entry_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_pnp_match_info),
            "::",
            stringify!(entry_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mod_pnp_match_info>())).num_entry as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mod_pnp_match_info),
            "::",
            stringify!(num_entry)
        )
    );
}
#[doc = " descr is a string that describes each entry in the table. The general"]
#[doc = " form is the grammar (TYPE:pnp_name[/pnp_name];)*"]
#[doc = " where TYPE is one of the following:"]
#[doc = "\tU8\tuint8_t element"]
#[doc = "\tV8\tlike U8 and 0xff means match any"]
#[doc = "\tG16\tuint16_t element, any value >= matches"]
#[doc = "\tL16\tuint16_t element, any value <= matches"]
#[doc = "\tM16\tuint16_t element, mask of which of the following fields to use."]
#[doc = "\tU16\tuint16_t element"]
#[doc = "\tV16\tlike U16 and 0xffff means match any"]
#[doc = "\tU32\tuint32_t element"]
#[doc = "\tV32\tlike U32 and 0xffffffff means match any"]
#[doc = "\tW32\tTwo 16-bit values with first pnp_name in LSW and second in MSW."]
#[doc = "\tZ\tpointer to a string to match exactly"]
#[doc = "\tD\tpointer to a string to human readable description for device"]
#[doc = "\tP\tA pointer that should be ignored"]
#[doc = "\tE\tEISA PNP Identifier (in binary, but bus publishes string)"]
#[doc = "\tT\tKey for whole table. pnp_name=value. must be last, if present."]
#[doc = ""]
#[doc = " The pnp_name \"#\" is reserved for other fields that should be ignored."]
#[doc = " Otherwise pnp_name must match the name from the parent device's pnpinfo"]
#[doc = " output. The second pnp_name is used for the W32 type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sx {
    pub lock_object: lock_object,
    pub sx_lock: usize,
}
#[test]
fn bindgen_test_layout_sx() {
    assert_eq!(
        ::core::mem::size_of::<sx>(),
        32usize,
        concat!("Size of: ", stringify!(sx))
    );
    assert_eq!(
        ::core::mem::align_of::<sx>(),
        8usize,
        concat!("Alignment of ", stringify!(sx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sx>())).lock_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sx),
            "::",
            stringify!(lock_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sx>())).sx_lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sx),
            "::",
            stringify!(sx_lock)
        )
    );
}
extern "C" {
    pub static mut modules_sx: sx;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct linker_file {
    _unused: [u8; 0],
}
extern "C" {
    pub fn module_register_init(arg1: *const cty::c_void);
}
extern "C" {
    pub fn module_register(arg1: *const moduledata, arg2: *mut linker_file) -> cty::c_int;
}
extern "C" {
    pub fn module_lookupbyname(arg1: *const cty::c_char) -> module_t;
}
extern "C" {
    pub fn module_lookupbyid(arg1: cty::c_int) -> module_t;
}
extern "C" {
    pub fn module_quiesce(arg1: module_t) -> cty::c_int;
}
extern "C" {
    pub fn module_reference(arg1: module_t);
}
extern "C" {
    pub fn module_release(arg1: module_t);
}
extern "C" {
    pub fn module_unload(arg1: module_t) -> cty::c_int;
}
extern "C" {
    pub fn module_getid(arg1: module_t) -> cty::c_int;
}
extern "C" {
    pub fn module_getfnext(arg1: module_t) -> module_t;
}
extern "C" {
    pub fn module_getname(arg1: module_t) -> *const cty::c_char;
}
extern "C" {
    pub fn module_setspecific(arg1: module_t, arg2: *mut modspecific_t);
}
extern "C" {
    pub fn module_file(arg1: module_t) -> *mut linker_file;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct module_stat {
    pub version: cty::c_int,
    pub name: [cty::c_char; 32usize],
    pub refs: cty::c_int,
    pub id: cty::c_int,
    pub data: modspecific_t,
}
#[test]
fn bindgen_test_layout_module_stat() {
    assert_eq!(
        ::core::mem::size_of::<module_stat>(),
        56usize,
        concat!("Size of: ", stringify!(module_stat))
    );
    assert_eq!(
        ::core::mem::align_of::<module_stat>(),
        8usize,
        concat!("Alignment of ", stringify!(module_stat))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_stat>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(module_stat),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_stat>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(module_stat),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_stat>())).refs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(module_stat),
            "::",
            stringify!(refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_stat>())).id as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(module_stat),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<module_stat>())).data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(module_stat),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __hack {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct region_descriptor {
    _unused: [u8; 0],
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct invpcid_descr {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 8usize]>,
    pub addr: u64,
}
#[test]
fn bindgen_test_layout_invpcid_descr() {
    assert_eq!(
        ::core::mem::size_of::<invpcid_descr>(),
        16usize,
        concat!("Size of: ", stringify!(invpcid_descr))
    );
    assert_eq!(
        ::core::mem::align_of::<invpcid_descr>(),
        1usize,
        concat!("Alignment of ", stringify!(invpcid_descr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<invpcid_descr>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(invpcid_descr),
            "::",
            stringify!(addr)
        )
    );
}
impl invpcid_descr {
    #[inline]
    pub fn pcid(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 12u8) as u64) }
    }
    #[inline]
    pub fn set_pcid(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 12u8, val as u64)
        }
    }
    #[inline]
    pub fn pad(&self) -> u64 {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 52u8) as u64) }
    }
    #[inline]
    pub fn set_pad(&mut self, val: u64) {
        unsafe {
            let val: u64 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 52u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(pcid: u64, pad: u64) -> __BindgenBitfieldUnit<[u8; 8usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 8usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 12u8, {
            let pcid: u64 = unsafe { ::core::mem::transmute(pcid) };
            pcid as u64
        });
        __bindgen_bitfield_unit.set(12usize, 52u8, {
            let pad: u64 = unsafe { ::core::mem::transmute(pad) };
            pad as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const SGX_ECREATE: cty::c_uint = 0;
pub const SGX_EADD: cty::c_uint = 1;
pub const SGX_EINIT: cty::c_uint = 2;
pub const SGX_EREMOVE: cty::c_uint = 3;
pub const SGX_EDGBRD: cty::c_uint = 4;
pub const SGX_EDGBWR: cty::c_uint = 5;
pub const SGX_EEXTEND: cty::c_uint = 6;
pub const SGX_ELDU: cty::c_uint = 8;
pub const SGX_EBLOCK: cty::c_uint = 9;
pub const SGX_EPA: cty::c_uint = 10;
pub const SGX_EWB: cty::c_uint = 11;
pub const SGX_ETRACK: cty::c_uint = 12;
pub type _bindgen_ty_1 = cty::c_uint;
pub const SGX_PT_SECS: cty::c_uint = 0;
pub const SGX_PT_TCS: cty::c_uint = 1;
pub const SGX_PT_REG: cty::c_uint = 2;
pub const SGX_PT_VA: cty::c_uint = 3;
pub const SGX_PT_TRIM: cty::c_uint = 4;
pub type _bindgen_ty_2 = cty::c_uint;
extern "C" {
    pub fn sgx_encls(eax: u32, rbx: u64, rcx: u64, rdx: u64) -> cty::c_int;
}
extern "C" {
    pub fn reset_dbregs();
}
extern "C" {
    pub fn rdmsr_safe(msr: u_int, val: *mut u64) -> cty::c_int;
}
extern "C" {
    pub fn wrmsr_safe(msr: u_int, newval: u64) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callout_list {
    pub lh_first: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_list() {
    assert_eq!(
        ::core::mem::size_of::<callout_list>(),
        8usize,
        concat!("Size of: ", stringify!(callout_list))
    );
    assert_eq!(
        ::core::mem::align_of::<callout_list>(),
        8usize,
        concat!("Alignment of ", stringify!(callout_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout_list>())).lh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout_list),
            "::",
            stringify!(lh_first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callout_slist {
    pub slh_first: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_slist() {
    assert_eq!(
        ::core::mem::size_of::<callout_slist>(),
        8usize,
        concat!("Size of: ", stringify!(callout_slist))
    );
    assert_eq!(
        ::core::mem::align_of::<callout_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(callout_slist))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout_slist>())).slh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout_slist),
            "::",
            stringify!(slh_first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callout_tailq {
    pub tqh_first: *mut callout,
    pub tqh_last: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout_tailq() {
    assert_eq!(
        ::core::mem::size_of::<callout_tailq>(),
        16usize,
        concat!("Size of: ", stringify!(callout_tailq))
    );
    assert_eq!(
        ::core::mem::align_of::<callout_tailq>(),
        8usize,
        concat!("Alignment of ", stringify!(callout_tailq))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout_tailq>())).tqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout_tailq),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout_tailq>())).tqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(callout_tailq),
            "::",
            stringify!(tqh_last)
        )
    );
}
pub type callout_func_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct callout {
    pub c_links: callout__bindgen_ty_1,
    pub c_time: sbintime_t,
    pub c_precision: sbintime_t,
    pub c_arg: *mut cty::c_void,
    pub c_func: callout_func_t,
    pub c_lock: *mut lock_object,
    pub c_flags: cty::c_short,
    pub c_iflags: cty::c_short,
    pub c_cpu: cty::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union callout__bindgen_ty_1 {
    pub le: callout__bindgen_ty_1__bindgen_ty_1,
    pub sle: callout__bindgen_ty_1__bindgen_ty_2,
    pub tqe: callout__bindgen_ty_1__bindgen_ty_3,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callout__bindgen_ty_1__bindgen_ty_1 {
    pub le_next: *mut callout,
    pub le_prev: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(callout__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(callout__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<callout__bindgen_ty_1__bindgen_ty_1>())).le_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<callout__bindgen_ty_1__bindgen_ty_1>())).le_prev as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(callout__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callout__bindgen_ty_1__bindgen_ty_2 {
    pub sle_next: *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(callout__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(callout__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<callout__bindgen_ty_1__bindgen_ty_2>())).sle_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(sle_next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callout__bindgen_ty_1__bindgen_ty_3 {
    pub tqe_next: *mut callout,
    pub tqe_prev: *mut *mut callout,
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<callout__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!("Size of: ", stringify!(callout__bindgen_ty_1__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<callout__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(callout__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<callout__bindgen_ty_1__bindgen_ty_3>())).tqe_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<callout__bindgen_ty_1__bindgen_ty_3>())).tqe_prev as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(callout__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_callout__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<callout__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(callout__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<callout__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(callout__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout__bindgen_ty_1>())).le as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout__bindgen_ty_1),
            "::",
            stringify!(le)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout__bindgen_ty_1>())).sle as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout__bindgen_ty_1),
            "::",
            stringify!(sle)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout__bindgen_ty_1>())).tqe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout__bindgen_ty_1),
            "::",
            stringify!(tqe)
        )
    );
}
#[test]
fn bindgen_test_layout_callout() {
    assert_eq!(
        ::core::mem::size_of::<callout>(),
        64usize,
        concat!("Size of: ", stringify!(callout))
    );
    assert_eq!(
        ::core::mem::align_of::<callout>(),
        8usize,
        concat!("Alignment of ", stringify!(callout))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout>())).c_links as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout>())).c_time as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout>())).c_precision as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_precision)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout>())).c_arg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout>())).c_func as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout>())).c_lock as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout>())).c_flags as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout>())).c_iflags as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_iflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout>())).c_cpu as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(callout),
            "::",
            stringify!(c_cpu)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct callout_handle {
    pub callout: *mut callout,
}
#[test]
fn bindgen_test_layout_callout_handle() {
    assert_eq!(
        ::core::mem::size_of::<callout_handle>(),
        8usize,
        concat!("Size of: ", stringify!(callout_handle))
    );
    assert_eq!(
        ::core::mem::align_of::<callout_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(callout_handle))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<callout_handle>())).callout as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(callout_handle),
            "::",
            stringify!(callout)
        )
    );
}
extern "C" {
    pub fn callout_init(arg1: *mut callout, arg2: cty::c_int);
}
extern "C" {
    pub fn _callout_init_lock(arg1: *mut callout, arg2: *mut lock_object, arg3: cty::c_int);
}
extern "C" {
    pub fn callout_reset_sbt_on(
        arg1: *mut callout,
        arg2: sbintime_t,
        arg3: sbintime_t,
        arg4: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>,
        arg5: *mut cty::c_void,
        arg6: cty::c_int,
        arg7: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn callout_schedule(arg1: *mut callout, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn callout_schedule_on(
        arg1: *mut callout,
        arg2: cty::c_int,
        arg3: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _callout_stop_safe(
        arg1: *mut callout,
        arg2: cty::c_int,
        arg3: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>,
    ) -> cty::c_int;
}
extern "C" {
    pub fn callout_process(now: sbintime_t);
}
extern "C" {
    pub fn callout_when(
        sbt: sbintime_t,
        precision: sbintime_t,
        flags: cty::c_int,
        sbt_res: *mut sbintime_t,
        prec_res: *mut sbintime_t,
    );
}
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = __int_fast8_t;
pub type int_fast16_t = __int_fast16_t;
pub type int_fast32_t = __int_fast32_t;
pub type int_fast64_t = __int_fast64_t;
pub type uint_fast8_t = __uint_fast8_t;
pub type uint_fast16_t = __uint_fast16_t;
pub type uint_fast32_t = __uint_fast32_t;
pub type uint_fast64_t = __uint_fast64_t;
extern "C" {
    pub static mut cold: cty::c_int;
}
extern "C" {
    pub static mut suspend_blocked: cty::c_int;
}
extern "C" {
    pub static mut rebooting: cty::c_int;
}
extern "C" {
    pub static mut panicstr: *const cty::c_char;
}
extern "C" {
    pub static mut version: [cty::c_char; 0usize];
}
extern "C" {
    pub static mut compiler_version: [cty::c_char; 0usize];
}
extern "C" {
    pub static mut copyright: [cty::c_char; 0usize];
}
extern "C" {
    pub static mut kstack_pages: cty::c_int;
}
extern "C" {
    pub static mut pagesizes: [u_long; 0usize];
}
extern "C" {
    pub static mut physmem: cty::c_long;
}
extern "C" {
    pub static mut realmem: cty::c_long;
}
extern "C" {
    pub static mut rootdevnames: [*mut cty::c_char; 2usize];
}
extern "C" {
    pub static mut boothowto: cty::c_int;
}
extern "C" {
    pub static mut bootverbose: cty::c_int;
}
extern "C" {
    pub static mut maxusers: cty::c_int;
}
extern "C" {
    pub static mut ngroups_max: cty::c_int;
}
extern "C" {
    pub static mut vm_guest: cty::c_int;
}
pub const VM_GUEST_VM_GUEST_NO: VM_GUEST = 0;
pub const VM_GUEST_VM_GUEST_VM: VM_GUEST = 1;
pub const VM_GUEST_VM_GUEST_XEN: VM_GUEST = 2;
pub const VM_GUEST_VM_GUEST_HV: VM_GUEST = 3;
pub const VM_GUEST_VM_GUEST_VMWARE: VM_GUEST = 4;
pub const VM_GUEST_VM_GUEST_KVM: VM_GUEST = 5;
pub const VM_GUEST_VM_GUEST_BHYVE: VM_GUEST = 6;
pub const VM_GUEST_VM_LAST: VM_GUEST = 7;
pub type VM_GUEST = cty::c_uint;
extern "C" {
    pub fn panic(arg1: *const cty::c_char, ...);
}
extern "C" {
    pub fn vpanic(arg1: *const cty::c_char, arg2: *mut __va_list_tag);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: cty::c_int,
    pub tz_dsttime: cty::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::core::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::core::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bintime {
    pub sec: time_t,
    pub frac: u64,
}
#[test]
fn bindgen_test_layout_bintime() {
    assert_eq!(
        ::core::mem::size_of::<bintime>(),
        16usize,
        concat!("Size of: ", stringify!(bintime))
    );
    assert_eq!(
        ::core::mem::align_of::<bintime>(),
        8usize,
        concat!("Alignment of ", stringify!(bintime))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bintime>())).sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bintime),
            "::",
            stringify!(sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bintime>())).frac as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bintime),
            "::",
            stringify!(frac)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::core::mem::size_of::<itimerval>(),
        32usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::core::mem::align_of::<itimerval>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerval>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clockinfo {
    pub hz: cty::c_int,
    pub tick: cty::c_int,
    pub spare: cty::c_int,
    pub stathz: cty::c_int,
    pub profhz: cty::c_int,
}
#[test]
fn bindgen_test_layout_clockinfo() {
    assert_eq!(
        ::core::mem::size_of::<clockinfo>(),
        20usize,
        concat!("Size of: ", stringify!(clockinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<clockinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(clockinfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<clockinfo>())).hz as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<clockinfo>())).tick as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(tick)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<clockinfo>())).spare as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(spare)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<clockinfo>())).stathz as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(stathz)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<clockinfo>())).profhz as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(clockinfo),
            "::",
            stringify!(profhz)
        )
    );
}
extern "C" {
    pub fn inittodr(base: time_t);
}
extern "C" {
    pub fn resettodr();
}
extern "C" {
    pub static mut time_second: time_t;
}
extern "C" {
    pub static mut time_uptime: time_t;
}
extern "C" {
    pub static mut tc_tick_bt: bintime;
}
extern "C" {
    pub static mut tc_tick_sbt: sbintime_t;
}
extern "C" {
    pub static mut tick_bt: bintime;
}
extern "C" {
    pub static mut tick_sbt: sbintime_t;
}
extern "C" {
    pub static mut tc_precexp: cty::c_int;
}
extern "C" {
    pub static mut tc_timepercentage: cty::c_int;
}
extern "C" {
    pub static mut bt_timethreshold: bintime;
}
extern "C" {
    pub static mut bt_tickthreshold: bintime;
}
extern "C" {
    pub static mut sbt_timethreshold: sbintime_t;
}
extern "C" {
    pub static mut sbt_tickthreshold: sbintime_t;
}
extern "C" {
    pub static mut rtc_generation: cty::c_int;
}
extern "C" {
    pub fn binuptime(bt: *mut bintime);
}
extern "C" {
    pub fn nanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn microuptime(tvp: *mut timeval);
}
extern "C" {
    pub fn bintime(bt: *mut bintime);
}
extern "C" {
    pub fn nanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn microtime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbinuptime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanouptime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrouptime(tvp: *mut timeval);
}
extern "C" {
    pub fn getbintime(bt: *mut bintime);
}
extern "C" {
    pub fn getnanotime(tsp: *mut timespec);
}
extern "C" {
    pub fn getmicrotime(tvp: *mut timeval);
}
extern "C" {
    pub fn getboottime(boottime: *mut timeval);
}
extern "C" {
    pub fn getboottimebin(boottimebin: *mut bintime);
}
extern "C" {
    pub fn itimerdecr(itp: *mut itimerval, usec: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn itimerfix(tv: *mut timeval) -> cty::c_int;
}
extern "C" {
    pub fn ppsratecheck(arg1: *mut timeval, arg2: *mut cty::c_int, arg3: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ratecheck(arg1: *mut timeval, arg2: *const timeval) -> cty::c_int;
}
extern "C" {
    pub fn timevaladd(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn timevalsub(t1: *mut timeval, t2: *const timeval);
}
extern "C" {
    pub fn tvtohz(tv: *mut timeval) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct priority {
    pub pri_class: u_char,
    pub pri_level: u_char,
    pub pri_native: u_char,
    pub pri_user: u_char,
}
#[test]
fn bindgen_test_layout_priority() {
    assert_eq!(
        ::core::mem::size_of::<priority>(),
        4usize,
        concat!("Size of: ", stringify!(priority))
    );
    assert_eq!(
        ::core::mem::align_of::<priority>(),
        1usize,
        concat!("Alignment of ", stringify!(priority))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<priority>())).pri_class as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(priority),
            "::",
            stringify!(pri_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<priority>())).pri_level as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(priority),
            "::",
            stringify!(pri_level)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<priority>())).pri_native as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(priority),
            "::",
            stringify!(pri_native)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<priority>())).pri_user as *const _ as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(priority),
            "::",
            stringify!(pri_user)
        )
    );
}
extern "C" {
    pub fn htonl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn htons(arg1: __uint16_t) -> __uint16_t;
}
extern "C" {
    pub fn ntohl(arg1: __uint32_t) -> __uint32_t;
}
extern "C" {
    pub fn ntohs(arg1: __uint16_t) -> __uint16_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bitset {
    pub __bits: [cty::c_long; 1usize],
}
#[test]
fn bindgen_test_layout_bitset() {
    assert_eq!(
        ::core::mem::size_of::<bitset>(),
        8usize,
        concat!("Size of: ", stringify!(bitset))
    );
    assert_eq!(
        ::core::mem::align_of::<bitset>(),
        8usize,
        concat!("Alignment of ", stringify!(bitset))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<bitset>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bitset),
            "::",
            stringify!(__bits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _cpuset {
    pub __bits: [cty::c_long; 4usize],
}
#[test]
fn bindgen_test_layout__cpuset() {
    assert_eq!(
        ::core::mem::size_of::<_cpuset>(),
        32usize,
        concat!("Size of: ", stringify!(_cpuset))
    );
    assert_eq!(
        ::core::mem::align_of::<_cpuset>(),
        8usize,
        concat!("Alignment of ", stringify!(_cpuset))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_cpuset>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_cpuset),
            "::",
            stringify!(__bits)
        )
    );
}
pub type cpuset_t = _cpuset;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_object {
    pub lo_name: *const cty::c_char,
    pub lo_flags: u_int,
    pub lo_data: u_int,
    pub lo_witness: *mut witness,
}
#[test]
fn bindgen_test_layout_lock_object() {
    assert_eq!(
        ::core::mem::size_of::<lock_object>(),
        24usize,
        concat!("Size of: ", stringify!(lock_object))
    );
    assert_eq!(
        ::core::mem::align_of::<lock_object>(),
        8usize,
        concat!("Alignment of ", stringify!(lock_object))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lock_object>())).lo_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_object),
            "::",
            stringify!(lo_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lock_object>())).lo_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_object),
            "::",
            stringify!(lo_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lock_object>())).lo_data as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_object),
            "::",
            stringify!(lo_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lock_object>())).lo_witness as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_object),
            "::",
            stringify!(lo_witness)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtx {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
}
#[test]
fn bindgen_test_layout_mtx() {
    assert_eq!(
        ::core::mem::size_of::<mtx>(),
        32usize,
        concat!("Size of: ", stringify!(mtx))
    );
    assert_eq!(
        ::core::mem::align_of::<mtx>(),
        8usize,
        concat!("Alignment of ", stringify!(mtx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mtx>())).lock_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mtx),
            "::",
            stringify!(lock_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mtx>())).mtx_lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mtx),
            "::",
            stringify!(mtx_lock)
        )
    );
}
#[repr(C)]
#[repr(align(64))]
#[derive(Copy, Clone)]
pub struct mtx_padalign {
    pub lock_object: lock_object,
    pub mtx_lock: usize,
}
#[test]
fn bindgen_test_layout_mtx_padalign() {
    assert_eq!(
        ::core::mem::size_of::<mtx_padalign>(),
        64usize,
        concat!("Size of: ", stringify!(mtx_padalign))
    );
    assert_eq!(
        ::core::mem::align_of::<mtx_padalign>(),
        64usize,
        concat!("Alignment of ", stringify!(mtx_padalign))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mtx_padalign>())).lock_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mtx_padalign),
            "::",
            stringify!(lock_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mtx_padalign>())).mtx_lock as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mtx_padalign),
            "::",
            stringify!(mtx_lock)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmpriolist {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmpriolist() {
    assert_eq!(
        ::core::mem::size_of::<rmpriolist>(),
        8usize,
        concat!("Size of: ", stringify!(rmpriolist))
    );
    assert_eq!(
        ::core::mem::align_of::<rmpriolist>(),
        8usize,
        concat!("Alignment of ", stringify!(rmpriolist))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rmpriolist>())).lh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmpriolist),
            "::",
            stringify!(lh_first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rm_queue {
    pub rmq_next: *mut rm_queue,
    pub rmq_prev: *mut rm_queue,
}
#[test]
fn bindgen_test_layout_rm_queue() {
    assert_eq!(
        ::core::mem::size_of::<rm_queue>(),
        16usize,
        concat!("Size of: ", stringify!(rm_queue))
    );
    assert_eq!(
        ::core::mem::align_of::<rm_queue>(),
        8usize,
        concat!("Alignment of ", stringify!(rm_queue))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rm_queue>())).rmq_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_queue),
            "::",
            stringify!(rmq_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rm_queue>())).rmq_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_queue),
            "::",
            stringify!(rmq_prev)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rmlock {
    pub lock_object: lock_object,
    pub rm_writecpus: cpuset_t,
    pub rm_activeReaders: rmlock__bindgen_ty_1,
    pub _rm_lock: rmlock__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rmlock__bindgen_ty_1 {
    pub lh_first: *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<rmlock__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(rmlock__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<rmlock__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rmlock__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rmlock__bindgen_ty_1>())).lh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmlock__bindgen_ty_1),
            "::",
            stringify!(lh_first)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rmlock__bindgen_ty_2 {
    pub _rm_wlock_object: lock_object,
    pub _rm_lock_mtx: mtx,
    pub _rm_lock_sx: sx,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_rmlock__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<rmlock__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(rmlock__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<rmlock__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rmlock__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rmlock__bindgen_ty_2>()))._rm_wlock_object as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmlock__bindgen_ty_2),
            "::",
            stringify!(_rm_wlock_object)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rmlock__bindgen_ty_2>()))._rm_lock_mtx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmlock__bindgen_ty_2),
            "::",
            stringify!(_rm_lock_mtx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rmlock__bindgen_ty_2>()))._rm_lock_sx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmlock__bindgen_ty_2),
            "::",
            stringify!(_rm_lock_sx)
        )
    );
}
#[test]
fn bindgen_test_layout_rmlock() {
    assert_eq!(
        ::core::mem::size_of::<rmlock>(),
        96usize,
        concat!("Size of: ", stringify!(rmlock))
    );
    assert_eq!(
        ::core::mem::align_of::<rmlock>(),
        8usize,
        concat!("Alignment of ", stringify!(rmlock))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rmlock>())).lock_object as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rmlock),
            "::",
            stringify!(lock_object)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rmlock>())).rm_writecpus as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rmlock),
            "::",
            stringify!(rm_writecpus)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rmlock>())).rm_activeReaders as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rmlock),
            "::",
            stringify!(rm_activeReaders)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rmlock>()))._rm_lock as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rmlock),
            "::",
            stringify!(_rm_lock)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rm_priotracker {
    pub rmp_cpuQueue: rm_queue,
    pub rmp_rmlock: *mut rmlock,
    pub rmp_thread: *mut thread,
    pub rmp_flags: cty::c_int,
    pub rmp_qentry: rm_priotracker__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rm_priotracker__bindgen_ty_1 {
    pub le_next: *mut rm_priotracker,
    pub le_prev: *mut *mut rm_priotracker,
}
#[test]
fn bindgen_test_layout_rm_priotracker__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<rm_priotracker__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(rm_priotracker__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<rm_priotracker__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rm_priotracker__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rm_priotracker__bindgen_ty_1>())).le_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_priotracker__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<rm_priotracker__bindgen_ty_1>())).le_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_priotracker__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_rm_priotracker() {
    assert_eq!(
        ::core::mem::size_of::<rm_priotracker>(),
        56usize,
        concat!("Size of: ", stringify!(rm_priotracker))
    );
    assert_eq!(
        ::core::mem::align_of::<rm_priotracker>(),
        8usize,
        concat!("Alignment of ", stringify!(rm_priotracker))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rm_priotracker>())).rmp_cpuQueue as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_priotracker),
            "::",
            stringify!(rmp_cpuQueue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rm_priotracker>())).rmp_rmlock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_priotracker),
            "::",
            stringify!(rmp_rmlock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rm_priotracker>())).rmp_thread as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_priotracker),
            "::",
            stringify!(rmp_thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rm_priotracker>())).rmp_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_priotracker),
            "::",
            stringify!(rmp_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rm_priotracker>())).rmp_qentry as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rm_priotracker),
            "::",
            stringify!(rmp_qentry)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: cty::c_long,
    pub ru_ixrss: cty::c_long,
    pub ru_idrss: cty::c_long,
    pub ru_isrss: cty::c_long,
    pub ru_minflt: cty::c_long,
    pub ru_majflt: cty::c_long,
    pub ru_nswap: cty::c_long,
    pub ru_inblock: cty::c_long,
    pub ru_oublock: cty::c_long,
    pub ru_msgsnd: cty::c_long,
    pub ru_msgrcv: cty::c_long,
    pub ru_nsignals: cty::c_long,
    pub ru_nvcsw: cty::c_long,
    pub ru_nivcsw: cty::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    assert_eq!(
        ::core::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::core::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rusage>())).ru_utime as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rusage>())).ru_stime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rusage>())).ru_maxrss as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rusage>())).ru_ixrss as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rusage>())).ru_idrss as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rusage>())).ru_isrss as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rusage>())).ru_minflt as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rusage>())).ru_majflt as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rusage>())).ru_nswap as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rusage>())).ru_inblock as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rusage>())).ru_oublock as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rusage>())).ru_msgsnd as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rusage>())).ru_msgrcv as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rusage>())).ru_nsignals as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rusage>())).ru_nvcsw as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rusage>())).ru_nivcsw as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __wrusage {
    pub wru_self: rusage,
    pub wru_children: rusage,
}
#[test]
fn bindgen_test_layout___wrusage() {
    assert_eq!(
        ::core::mem::size_of::<__wrusage>(),
        288usize,
        concat!("Size of: ", stringify!(__wrusage))
    );
    assert_eq!(
        ::core::mem::align_of::<__wrusage>(),
        8usize,
        concat!("Alignment of ", stringify!(__wrusage))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__wrusage>())).wru_self as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__wrusage),
            "::",
            stringify!(wru_self)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__wrusage>())).wru_children as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(__wrusage),
            "::",
            stringify!(wru_children)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    assert_eq!(
        ::core::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::core::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlimit>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rlimit>())).rlim_max as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct orlimit {
    pub rlim_cur: __int32_t,
    pub rlim_max: __int32_t,
}
#[test]
fn bindgen_test_layout_orlimit() {
    assert_eq!(
        ::core::mem::size_of::<orlimit>(),
        8usize,
        concat!("Size of: ", stringify!(orlimit))
    );
    assert_eq!(
        ::core::mem::align_of::<orlimit>(),
        4usize,
        concat!("Alignment of ", stringify!(orlimit))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<orlimit>())).rlim_cur as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(orlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<orlimit>())).rlim_max as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(orlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct loadavg {
    pub ldavg: [__fixpt_t; 3usize],
    pub fscale: cty::c_long,
}
#[test]
fn bindgen_test_layout_loadavg() {
    assert_eq!(
        ::core::mem::size_of::<loadavg>(),
        24usize,
        concat!("Size of: ", stringify!(loadavg))
    );
    assert_eq!(
        ::core::mem::align_of::<loadavg>(),
        8usize,
        concat!("Alignment of ", stringify!(loadavg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<loadavg>())).ldavg as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(loadavg),
            "::",
            stringify!(ldavg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<loadavg>())).fscale as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(loadavg),
            "::",
            stringify!(fscale)
        )
    );
}
extern "C" {
    pub static mut averunnable: loadavg;
}
extern "C" {
    pub fn read_cpu_time(cp_time: *mut cty::c_long);
}
extern "C" {
    pub static mut __start_set_pcpu: *mut usize;
}
extern "C" {
    pub static mut __stop_set_pcpu: *mut usize;
}
extern "C" {
    pub static mut dpcpu_off: [usize; 0usize];
}
#[repr(C)]
#[repr(align(128))]
#[derive(Copy, Clone)]
pub struct pcpu {
    pub pc_curthread: *mut thread,
    pub pc_idlethread: *mut thread,
    pub pc_fpcurthread: *mut thread,
    pub pc_deadthread: *mut thread,
    pub pc_curpcb: *mut pcb,
    pub pc_switchtime: u64,
    pub pc_switchticks: cty::c_int,
    pub pc_cpuid: u_int,
    pub pc_allcpu: pcpu__bindgen_ty_1,
    pub pc_spinlocks: *mut lock_list_entry,
    pub pc_cp_time: [cty::c_long; 5usize],
    pub pc_device: *mut device,
    pub pc_netisr: *mut cty::c_void,
    pub pc_unused1: cty::c_int,
    pub pc_domain: cty::c_int,
    pub pc_rm_queue: rm_queue,
    pub pc_dynamic: usize,
    pub pc_early_dummy_counter: u64,
    pub __bindgen_padding_0: [u8; 88usize],
    pub pc_monitorbuf: [cty::c_char; 128usize],
    pub pc_prvspace: *mut pcpu,
    pub pc_curpmap: *mut pmap,
    pub pc_tssp: *mut amd64tss,
    pub pc_commontssp: *mut amd64tss,
    pub pc_kcr3: u64,
    pub pc_ucr3: u64,
    pub pc_saved_ucr3: u64,
    pub pc_rsp0: register_t,
    pub pc_scratch_rsp: register_t,
    pub pc_scratch_rax: register_t,
    pub pc_apic_id: u_int,
    pub pc_acpi_id: u_int,
    pub pc_fs32p: *mut user_segment_descriptor,
    pub pc_gs32p: *mut user_segment_descriptor,
    pub pc_ldt: *mut system_segment_descriptor,
    pub pc_tss: *mut system_segment_descriptor,
    pub pc_pm_save_cnt: u64,
    pub pc_cmci_mask: u_int,
    pub pc_dbreg: [u64; 16usize],
    pub pc_pti_stack: [u64; 16usize],
    pub pc_pti_rsp0: register_t,
    pub pc_dbreg_cmd: cty::c_int,
    pub pc_vcpu_id: u_int,
    pub pc_pcid_next: u32,
    pub pc_pcid_gen: u32,
    pub pc_smp_tlb_done: u32,
    pub pc_ibpb_set: u32,
    pub pc_mds_buf: *mut cty::c_void,
    pub pc_mds_buf64: *mut cty::c_void,
    pub pc_pad: [u32; 2usize],
    pub pc_mds_tmp: [u8; 64usize],
    pub __pad: [cty::c_char; 3176usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcpu__bindgen_ty_1 {
    pub stqe_next: *mut pcpu,
}
#[test]
fn bindgen_test_layout_pcpu__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<pcpu__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(pcpu__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<pcpu__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pcpu__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu__bindgen_ty_1>())).stqe_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu__bindgen_ty_1),
            "::",
            stringify!(stqe_next)
        )
    );
}
#[test]
fn bindgen_test_layout_pcpu() {
    assert_eq!(
        ::core::mem::size_of::<pcpu>(),
        4096usize,
        concat!("Size of: ", stringify!(pcpu))
    );
    assert_eq!(
        ::core::mem::align_of::<pcpu>(),
        128usize,
        concat!("Alignment of ", stringify!(pcpu))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_curthread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_curthread)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_idlethread as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_idlethread)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_fpcurthread as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_fpcurthread)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_deadthread as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_deadthread)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_curpcb as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_curpcb)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_switchtime as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_switchtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_switchticks as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_switchticks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_cpuid as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_cpuid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_allcpu as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_allcpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_spinlocks as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_spinlocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_cp_time as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_cp_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_device as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_device)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_netisr as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_netisr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_unused1 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_unused1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_domain as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_rm_queue as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_rm_queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_dynamic as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_dynamic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_early_dummy_counter as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_early_dummy_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_monitorbuf as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_monitorbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_prvspace as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_prvspace)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_curpmap as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_curpmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_tssp as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_tssp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_commontssp as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_commontssp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_kcr3 as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_kcr3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_ucr3 as *const _ as usize },
        424usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_ucr3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_saved_ucr3 as *const _ as usize },
        432usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_saved_ucr3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_rsp0 as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_rsp0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_scratch_rsp as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_scratch_rsp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_scratch_rax as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_scratch_rax)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_apic_id as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_apic_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_acpi_id as *const _ as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_acpi_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_fs32p as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_fs32p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_gs32p as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_gs32p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_ldt as *const _ as usize },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_ldt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_tss as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_tss)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_pm_save_cnt as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_pm_save_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_cmci_mask as *const _ as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_cmci_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_dbreg as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_dbreg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_pti_stack as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_pti_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_pti_rsp0 as *const _ as usize },
        776usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_pti_rsp0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_dbreg_cmd as *const _ as usize },
        784usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_dbreg_cmd)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_vcpu_id as *const _ as usize },
        788usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_vcpu_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_pcid_next as *const _ as usize },
        792usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_pcid_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_pcid_gen as *const _ as usize },
        796usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_pcid_gen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_smp_tlb_done as *const _ as usize },
        800usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_smp_tlb_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_ibpb_set as *const _ as usize },
        804usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_ibpb_set)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_mds_buf as *const _ as usize },
        808usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_mds_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_mds_buf64 as *const _ as usize },
        816usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_mds_buf64)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_pad as *const _ as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).pc_mds_tmp as *const _ as usize },
        832usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(pc_mds_tmp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pcpu>())).__pad as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(pcpu),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpuhead {
    pub stqh_first: *mut pcpu,
    pub stqh_last: *mut *mut pcpu,
}
#[test]
fn bindgen_test_layout_cpuhead() {
    assert_eq!(
        ::core::mem::size_of::<cpuhead>(),
        16usize,
        concat!("Size of: ", stringify!(cpuhead))
    );
    assert_eq!(
        ::core::mem::align_of::<cpuhead>(),
        8usize,
        concat!("Alignment of ", stringify!(cpuhead))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpuhead>())).stqh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuhead),
            "::",
            stringify!(stqh_first)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpuhead>())).stqh_last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cpuhead),
            "::",
            stringify!(stqh_last)
        )
    );
}
extern "C" {
    pub static mut cpuhead: cpuhead;
}
extern "C" {
    pub static mut cpuid_to_pcpu: [*mut pcpu; 0usize];
}
extern "C" {
    pub static mut __pcpu: *mut pcpu;
}
extern "C" {
    pub static mut temp_bsp_pcpu: pcpu;
}
extern "C" {
    pub fn cpu_pcpu_init(pcpu: *mut pcpu, cpuid: cty::c_int, size: size_t);
}
extern "C" {
    pub fn db_show_mdpcpu(pcpu: *mut pcpu);
}
extern "C" {
    pub fn dpcpu_alloc(size: cty::c_int) -> *mut cty::c_void;
}
extern "C" {
    pub fn dpcpu_copy(s: *mut cty::c_void, size: cty::c_int);
}
extern "C" {
    pub fn dpcpu_free(s: *mut cty::c_void, size: cty::c_int);
}
extern "C" {
    pub fn dpcpu_init(dpcpu: *mut cty::c_void, cpuid: cty::c_int);
}
extern "C" {
    pub fn pcpu_destroy(pcpu: *mut pcpu);
}
extern "C" {
    pub fn pcpu_find(cpuid: u_int) -> *mut pcpu;
}
extern "C" {
    pub fn pcpu_init(pcpu: *mut pcpu, cpuid: cty::c_int, size: size_t);
}
extern "C" {
    pub static mut osreldate: cty::c_int;
}
extern "C" {
    pub static mut dynamic_kenv: bool_;
}
extern "C" {
    pub static mut kenv_lock: mtx;
}
extern "C" {
    pub static mut kern_envp: *mut cty::c_char;
}
extern "C" {
    pub static mut md_envp: *mut cty::c_char;
}
extern "C" {
    pub static mut static_env: [cty::c_char; 0usize];
}
extern "C" {
    pub static mut static_hints: [cty::c_char; 0usize];
}
extern "C" {
    pub static mut kenvp: *mut *mut cty::c_char;
}
extern "C" {
    pub static mut zero_region: *const cty::c_void;
}
extern "C" {
    pub static mut unmapped_buf_allowed: cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct inpcb {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_ {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct socket {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tty {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ucred {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _jmp_buf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct trapframe {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventtimer {
    _unused: [u8; 0],
}
extern "C" {
    pub fn setjmp(arg1: *mut _jmp_buf) -> cty::c_int;
}
extern "C" {
    pub fn longjmp(arg1: *mut _jmp_buf, arg2: cty::c_int);
}
extern "C" {
    pub fn dumpstatus(addr: vm_offset_t, count: off_t) -> cty::c_int;
}
extern "C" {
    pub fn nullop() -> cty::c_int;
}
extern "C" {
    pub fn eopnotsupp() -> cty::c_int;
}
extern "C" {
    pub fn ureadc(arg1: cty::c_int, arg2: *mut uio) -> cty::c_int;
}
extern "C" {
    pub fn hashdestroy(arg1: *mut cty::c_void, arg2: *mut malloc_type, arg3: u_long);
}
extern "C" {
    pub fn hashinit(
        count: cty::c_int,
        type_: *mut malloc_type,
        hashmask: *mut u_long,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn hashinit_flags(
        count: cty::c_int,
        type_: *mut malloc_type,
        hashmask: *mut u_long,
        flags: cty::c_int,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn phashinit(
        count: cty::c_int,
        type_: *mut malloc_type,
        nentries: *mut u_long,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn phashinit_flags(
        count: cty::c_int,
        type_: *mut malloc_type,
        nentries: *mut u_long,
        flags: cty::c_int,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn g_waitidle();
}
extern "C" {
    pub fn cpu_boot(arg1: cty::c_int);
}
extern "C" {
    pub fn cpu_flush_dcache(arg1: *mut cty::c_void, arg2: size_t);
}
extern "C" {
    pub fn cpu_rootconf();
}
extern "C" {
    pub fn critical_enter_KBI();
}
extern "C" {
    pub fn critical_exit_KBI();
}
extern "C" {
    pub fn critical_exit_preempt();
}
extern "C" {
    pub fn init_param1();
}
extern "C" {
    pub fn init_param2(physpages: cty::c_long);
}
extern "C" {
    pub fn init_static_kenv(arg1: *mut cty::c_char, arg2: size_t);
}
extern "C" {
    pub fn tablefull(arg1: *const cty::c_char);
}
extern "C" {
    pub fn kvprintf(
        arg1: *const cty::c_char,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: cty::c_int, arg2: *mut cty::c_void),
        >,
        arg3: *mut cty::c_void,
        arg4: cty::c_int,
        arg5: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn log(arg1: cty::c_int, arg2: *const cty::c_char, ...);
}
extern "C" {
    pub fn log_console(arg1: *mut uio);
}
extern "C" {
    pub fn vlog(arg1: cty::c_int, arg2: *const cty::c_char, arg3: *mut __va_list_tag);
}
extern "C" {
    pub fn asprintf(
        ret: *mut *mut cty::c_char,
        mtp: *mut malloc_type,
        format: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn printf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut cty::c_char,
        arg2: size_t,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn sprintf(buf: *mut cty::c_char, arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn uprintf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const cty::c_char, arg2: *mut __va_list_tag) -> cty::c_int;
}
extern "C" {
    pub fn vasprintf(
        ret: *mut *mut cty::c_char,
        mtp: *mut malloc_type,
        format: *const cty::c_char,
        ap: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut cty::c_char,
        arg2: size_t,
        arg3: *const cty::c_char,
        arg4: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsnrprintf(
        arg1: *mut cty::c_char,
        arg2: size_t,
        arg3: cty::c_int,
        arg4: *const cty::c_char,
        arg5: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsprintf(
        buf: *mut cty::c_char,
        arg1: *const cty::c_char,
        arg2: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn ttyprintf(arg1: *mut tty, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vsscanf(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: *mut __va_list_tag,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strtol(
        arg1: *const cty::c_char,
        arg2: *mut *mut cty::c_char,
        arg3: cty::c_int,
    ) -> cty::c_long;
}
extern "C" {
    pub fn strtoul(
        arg1: *const cty::c_char,
        arg2: *mut *mut cty::c_char,
        arg3: cty::c_int,
    ) -> u_long;
}
extern "C" {
    pub fn strtoq(
        arg1: *const cty::c_char,
        arg2: *mut *mut cty::c_char,
        arg3: cty::c_int,
    ) -> quad_t;
}
extern "C" {
    pub fn strtouq(
        arg1: *const cty::c_char,
        arg2: *mut *mut cty::c_char,
        arg3: cty::c_int,
    ) -> u_quad_t;
}
extern "C" {
    pub fn tprintf(p: *mut proc_, pri: cty::c_int, arg1: *const cty::c_char, ...);
}
extern "C" {
    pub fn vtprintf(
        arg1: *mut proc_,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: *mut __va_list_tag,
    );
}
extern "C" {
    pub fn hexdump(
        ptr: *const cty::c_void,
        length: cty::c_int,
        hdr: *const cty::c_char,
        flags: cty::c_int,
    );
}
extern "C" {
    pub fn bcopy(from: *const cty::c_void, to: *mut cty::c_void, len: size_t);
}
extern "C" {
    pub fn bzero(buf: *mut cty::c_void, len: size_t);
}
extern "C" {
    pub fn explicit_bzero(arg1: *mut cty::c_void, arg2: size_t);
}
extern "C" {
    pub fn bcmp(b1: *const cty::c_void, b2: *const cty::c_void, len: size_t) -> cty::c_int;
}
extern "C" {
    pub fn memset(buf: *mut cty::c_void, c: cty::c_int, len: size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn memcpy(to: *mut cty::c_void, from: *const cty::c_void, len: size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn memmove(dest: *mut cty::c_void, src: *const cty::c_void, n: size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn memcmp(b1: *const cty::c_void, b2: *const cty::c_void, len: size_t) -> cty::c_int;
}
extern "C" {
    pub fn memset_early(buf: *mut cty::c_void, c: cty::c_int, len: size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn memcpy_early(
        to: *mut cty::c_void,
        from: *const cty::c_void,
        len: size_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn memmove_early(
        dest: *mut cty::c_void,
        src: *const cty::c_void,
        n: size_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn copystr(
        kfaddr: *const cty::c_void,
        kdaddr: *mut cty::c_void,
        len: size_t,
        lencopied: *mut size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn copyinstr(
        udaddr: *const cty::c_void,
        kaddr: *mut cty::c_void,
        len: size_t,
        lencopied: *mut size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn copyin(udaddr: *const cty::c_void, kaddr: *mut cty::c_void, len: size_t) -> cty::c_int;
}
extern "C" {
    pub fn copyin_nofault(
        udaddr: *const cty::c_void,
        kaddr: *mut cty::c_void,
        len: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn copyout(kaddr: *const cty::c_void, udaddr: *mut cty::c_void, len: size_t) -> cty::c_int;
}
extern "C" {
    pub fn copyout_nofault(
        kaddr: *const cty::c_void,
        udaddr: *mut cty::c_void,
        len: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fubyte(base: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn fuword(base: *const cty::c_void) -> cty::c_long;
}
extern "C" {
    pub fn fuword16(base: *const cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn fuword32(base: *const cty::c_void) -> i32;
}
extern "C" {
    pub fn fuword64(base: *const cty::c_void) -> i64;
}
extern "C" {
    pub fn fueword(base: *const cty::c_void, val: *mut cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn fueword32(base: *const cty::c_void, val: *mut i32) -> cty::c_int;
}
extern "C" {
    pub fn fueword64(base: *const cty::c_void, val: *mut i64) -> cty::c_int;
}
extern "C" {
    pub fn subyte(base: *mut cty::c_void, byte: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn suword(base: *mut cty::c_void, word: cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn suword16(base: *mut cty::c_void, word: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn suword32(base: *mut cty::c_void, word: i32) -> cty::c_int;
}
extern "C" {
    pub fn suword64(base: *mut cty::c_void, word: i64) -> cty::c_int;
}
extern "C" {
    pub fn casuword32(base: *mut u32, oldval: u32, newval: u32) -> u32;
}
extern "C" {
    pub fn casuword(p: *mut u_long, oldval: u_long, newval: u_long) -> u_long;
}
extern "C" {
    pub fn casueword32(base: *mut u32, oldval: u32, oldvalp: *mut u32, newval: u32) -> cty::c_int;
}
extern "C" {
    pub fn casueword(
        p: *mut u_long,
        oldval: u_long,
        oldvalp: *mut u_long,
        newval: u_long,
    ) -> cty::c_int;
}
extern "C" {
    pub fn realitexpire(arg1: *mut cty::c_void);
}
extern "C" {
    pub fn sysbeep(hertz: cty::c_int, period: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn hardclock(cnt: cty::c_int, usermode: cty::c_int);
}
extern "C" {
    pub fn hardclock_sync(cpu: cty::c_int);
}
extern "C" {
    pub fn softclock(arg1: *mut cty::c_void);
}
extern "C" {
    pub fn statclock(cnt: cty::c_int, usermode: cty::c_int);
}
extern "C" {
    pub fn profclock(cnt: cty::c_int, usermode: cty::c_int, pc: uintfptr_t);
}
extern "C" {
    pub fn hardclockintr() -> cty::c_int;
}
extern "C" {
    pub fn startprofclock(arg1: *mut proc_);
}
extern "C" {
    pub fn stopprofclock(arg1: *mut proc_);
}
extern "C" {
    pub fn cpu_startprofclock();
}
extern "C" {
    pub fn cpu_stopprofclock();
}
extern "C" {
    pub fn suspendclock();
}
extern "C" {
    pub fn resumeclock();
}
extern "C" {
    pub fn cpu_idleclock() -> sbintime_t;
}
extern "C" {
    pub fn cpu_activeclock();
}
extern "C" {
    pub fn cpu_new_callout(cpu: cty::c_int, bt: sbintime_t, bt_opt: sbintime_t);
}
extern "C" {
    pub fn cpu_et_frequency(et: *mut eventtimer, newfreq: u64);
}
extern "C" {
    pub static mut cpu_disable_c2_sleep: cty::c_int;
}
extern "C" {
    pub static mut cpu_disable_c3_sleep: cty::c_int;
}
extern "C" {
    pub fn kern_getenv(name: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn freeenv(env: *mut cty::c_char);
}
extern "C" {
    pub fn getenv_int(name: *const cty::c_char, data: *mut cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn getenv_uint(name: *const cty::c_char, data: *mut cty::c_uint) -> cty::c_int;
}
extern "C" {
    pub fn getenv_long(name: *const cty::c_char, data: *mut cty::c_long) -> cty::c_int;
}
extern "C" {
    pub fn getenv_ulong(name: *const cty::c_char, data: *mut cty::c_ulong) -> cty::c_int;
}
extern "C" {
    pub fn getenv_string(
        name: *const cty::c_char,
        data: *mut cty::c_char,
        size: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn getenv_int64(name: *const cty::c_char, data: *mut i64) -> cty::c_int;
}
extern "C" {
    pub fn getenv_uint64(name: *const cty::c_char, data: *mut u64) -> cty::c_int;
}
extern "C" {
    pub fn getenv_quad(name: *const cty::c_char, data: *mut quad_t) -> cty::c_int;
}
extern "C" {
    pub fn kern_setenv(name: *const cty::c_char, value: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn kern_unsetenv(name: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn testenv(name: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn getenv_array(
        name: *const cty::c_char,
        data: *mut cty::c_void,
        size: cty::c_int,
        psize: *mut cty::c_int,
        type_size: cty::c_int,
        allow_signed: bool_,
    ) -> cty::c_int;
}
pub type cpu_tick_f = ::core::option::Option<unsafe extern "C" fn() -> u64>;
extern "C" {
    pub fn set_cputicker(func: cpu_tick_f, freq: u64, var: cty::c_uint);
}
extern "C" {
    pub static mut cpu_ticks: cpu_tick_f;
}
extern "C" {
    pub fn cpu_tickrate() -> u64;
}
extern "C" {
    pub fn cputick2usec(tick: u64) -> u64;
}
extern "C" {
    pub static mut bcd2bin_data: [u_char; 0usize];
}
extern "C" {
    pub static mut bin2bcd_data: [u_char; 0usize];
}
extern "C" {
    pub static mut hex2ascii_data: [cty::c_char; 0usize];
}
extern "C" {
    pub static mut arc4rand_iniseed_state: cty::c_int;
}
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_buf(arg1: *mut cty::c_void, arg2: size_t);
}
extern "C" {
    pub fn arc4random_uniform(arg1: u32) -> u32;
}
extern "C" {
    pub fn arc4rand(arg1: *mut cty::c_void, arg2: u_int, arg3: cty::c_int);
}
extern "C" {
    pub fn timingsafe_bcmp(
        arg1: *const cty::c_void,
        arg2: *const cty::c_void,
        arg3: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn bsearch(
        arg1: *const cty::c_void,
        arg2: *const cty::c_void,
        arg3: size_t,
        arg4: size_t,
        arg5: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const cty::c_void, arg2: *const cty::c_void) -> cty::c_int,
        >,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn fnmatch(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn locc(arg1: cty::c_int, arg2: *mut cty::c_char, arg3: u_int) -> cty::c_int;
}
extern "C" {
    pub fn memchr(s: *const cty::c_void, c: cty::c_int, n: size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn memcchr(s: *const cty::c_void, c: cty::c_int, n: size_t) -> *mut cty::c_void;
}
extern "C" {
    pub fn memmem(
        l: *const cty::c_void,
        l_len: size_t,
        s: *const cty::c_void,
        s_len: size_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn qsort(
        base: *mut cty::c_void,
        nmemb: size_t,
        size: size_t,
        compar: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const cty::c_void, arg2: *const cty::c_void) -> cty::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_r(
        base: *mut cty::c_void,
        nmemb: size_t,
        size: size_t,
        thunk: *mut cty::c_void,
        compar: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut cty::c_void,
                arg2: *const cty::c_void,
                arg3: *const cty::c_void,
            ) -> cty::c_int,
        >,
    );
}
extern "C" {
    pub fn random() -> u_long;
}
extern "C" {
    pub fn scanc(
        arg1: u_int,
        arg2: *const u_char,
        arg3: *const u_char,
        arg4: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn srandom(arg1: u_long);
}
extern "C" {
    pub fn strcasecmp(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strcat(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strchr(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcmp(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn strcpy(arg1: *mut cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strcspn(arg1: *const cty::c_char, arg2: *const cty::c_char) -> size_t;
}
extern "C" {
    pub fn strdup_flags(
        arg1: *const cty::c_char,
        arg2: *mut malloc_type,
        arg3: cty::c_int,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strdup(arg1: *const cty::c_char, arg2: *mut malloc_type) -> *mut cty::c_char;
}
extern "C" {
    pub fn strncat(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: size_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strndup(
        arg1: *const cty::c_char,
        arg2: size_t,
        arg3: *mut malloc_type,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strlcat(arg1: *mut cty::c_char, arg2: *const cty::c_char, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn strlcpy(arg1: *mut cty::c_char, arg2: *const cty::c_char, arg3: size_t) -> size_t;
}
extern "C" {
    pub fn strlen(arg1: *const cty::c_char) -> size_t;
}
extern "C" {
    pub fn strncasecmp(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn strncmp(arg1: *const cty::c_char, arg2: *const cty::c_char, arg3: size_t) -> cty::c_int;
}
extern "C" {
    pub fn strncpy(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: size_t,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn strnlen(arg1: *const cty::c_char, arg2: size_t) -> size_t;
}
extern "C" {
    pub fn strrchr(arg1: *const cty::c_char, arg2: cty::c_int) -> *mut cty::c_char;
}
extern "C" {
    pub fn strsep(arg1: *mut *mut cty::c_char, delim: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strspn(arg1: *const cty::c_char, arg2: *const cty::c_char) -> size_t;
}
extern "C" {
    pub fn strstr(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn strvalid(arg1: *const cty::c_char, arg2: size_t) -> cty::c_int;
}
extern "C" {
    pub static mut crc32_tab: [u32; 0usize];
}
extern "C" {
    pub fn calculate_crc32c(crc32c: u32, buffer: *const cty::c_uchar, length: cty::c_uint) -> u32;
}
extern "C" {
    pub fn sse42_crc32c(arg1: u32, arg2: *const cty::c_uchar, arg3: cty::c_uint) -> u32;
}
extern "C" {
    pub fn consinit();
}
extern "C" {
    pub fn cpu_initclocks();
}
extern "C" {
    pub fn cpu_initclocks_bsp();
}
extern "C" {
    pub fn cpu_initclocks_ap();
}
extern "C" {
    pub fn usrinfoinit();
}
extern "C" {
    pub fn kern_reboot(arg1: cty::c_int);
}
extern "C" {
    pub fn shutdown_nice(arg1: cty::c_int);
}
pub type timeout_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
extern "C" {
    pub fn callout_handle_init(arg1: *mut callout_handle);
}
extern "C" {
    pub fn timeout(arg1: timeout_t, arg2: *mut cty::c_void, arg3: cty::c_int) -> callout_handle;
}
extern "C" {
    pub fn untimeout(arg1: timeout_t, arg2: *mut cty::c_void, arg3: callout_handle);
}
extern "C" {
    pub fn _sleep(
        chan: *mut cty::c_void,
        lock: *mut lock_object,
        pri: cty::c_int,
        wmesg: *const cty::c_char,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn msleep_spin_sbt(
        chan: *mut cty::c_void,
        mtx: *mut mtx,
        wmesg: *const cty::c_char,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pause_sbt(
        wmesg: *const cty::c_char,
        sbt: sbintime_t,
        pr: sbintime_t,
        flags: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn wakeup(chan: *mut cty::c_void);
}
extern "C" {
    pub fn wakeup_one(chan: *mut cty::c_void);
}
extern "C" {
    pub fn wakeup_any(chan: *mut cty::c_void);
}
extern "C" {
    pub fn dev2udev(x: *mut cdev) -> dev_t;
}
extern "C" {
    pub fn devtoname(cdev: *mut cdev) -> *const cty::c_char;
}
extern "C" {
    pub fn devfs_iosize_max() -> size_t;
}
extern "C" {
    pub fn iosize_max() -> size_t;
}
extern "C" {
    pub fn poll_no_poll(events: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn DELAY(usec: cty::c_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct root_hold_token {
    pub flags: cty::c_int,
    pub who: *const cty::c_char,
    pub list: root_hold_token__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct root_hold_token__bindgen_ty_1 {
    pub tqe_next: *mut root_hold_token,
    pub tqe_prev: *mut *mut root_hold_token,
}
#[test]
fn bindgen_test_layout_root_hold_token__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<root_hold_token__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(root_hold_token__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<root_hold_token__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(root_hold_token__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<root_hold_token__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(root_hold_token__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<root_hold_token__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(root_hold_token__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_root_hold_token() {
    assert_eq!(
        ::core::mem::size_of::<root_hold_token>(),
        32usize,
        concat!("Size of: ", stringify!(root_hold_token))
    );
    assert_eq!(
        ::core::mem::align_of::<root_hold_token>(),
        8usize,
        concat!("Alignment of ", stringify!(root_hold_token))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<root_hold_token>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(root_hold_token),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<root_hold_token>())).who as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(root_hold_token),
            "::",
            stringify!(who)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<root_hold_token>())).list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(root_hold_token),
            "::",
            stringify!(list)
        )
    );
}
extern "C" {
    pub fn root_mount_hold(identifier: *const cty::c_char) -> *mut root_hold_token;
}
extern "C" {
    pub fn root_mount_hold_token(identifier: *const cty::c_char, h: *mut root_hold_token);
}
extern "C" {
    pub fn root_mount_rel(h: *mut root_hold_token);
}
extern "C" {
    pub fn root_mounted() -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unrhdr {
    _unused: [u8; 0],
}
extern "C" {
    pub fn new_unrhdr(low: cty::c_int, high: cty::c_int, mutex: *mut mtx) -> *mut unrhdr;
}
extern "C" {
    pub fn init_unrhdr(uh: *mut unrhdr, low: cty::c_int, high: cty::c_int, mutex: *mut mtx);
}
extern "C" {
    pub fn delete_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clear_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clean_unrhdr(uh: *mut unrhdr);
}
extern "C" {
    pub fn clean_unrhdrl(uh: *mut unrhdr);
}
extern "C" {
    pub fn alloc_unr(uh: *mut unrhdr) -> cty::c_int;
}
extern "C" {
    pub fn alloc_unr_specific(uh: *mut unrhdr, item: u_int) -> cty::c_int;
}
extern "C" {
    pub fn alloc_unrl(uh: *mut unrhdr) -> cty::c_int;
}
extern "C" {
    pub fn free_unr(uh: *mut unrhdr, item: u_int);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct unrhdr64 {
    pub counter: u64,
}
#[test]
fn bindgen_test_layout_unrhdr64() {
    assert_eq!(
        ::core::mem::size_of::<unrhdr64>(),
        8usize,
        concat!("Size of: ", stringify!(unrhdr64))
    );
    assert_eq!(
        ::core::mem::align_of::<unrhdr64>(),
        8usize,
        concat!("Alignment of ", stringify!(unrhdr64))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<unrhdr64>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(unrhdr64),
            "::",
            stringify!(counter)
        )
    );
}
extern "C" {
    pub fn intr_prof_stack_use(td: *mut thread, frame: *mut trapframe);
}
extern "C" {
    pub fn counted_warning(counter: *mut cty::c_uint, msg: *const cty::c_char);
}
extern "C" {
    pub fn _gone_in(major: cty::c_int, msg: *const cty::c_char);
}
extern "C" {
    pub fn _gone_in_dev(dev: *mut device, major: cty::c_int, msg: *const cty::c_char);
}
extern "C" {
    pub static mut kernelname: [cty::c_char; 1024usize];
}
extern "C" {
    pub static mut tick: cty::c_int;
}
extern "C" {
    pub static mut hz: cty::c_int;
}
extern "C" {
    pub static mut psratio: cty::c_int;
}
extern "C" {
    pub static mut stathz: cty::c_int;
}
extern "C" {
    pub static mut profhz: cty::c_int;
}
extern "C" {
    pub static mut profprocs: cty::c_int;
}
extern "C" {
    pub static mut ticks: cty::c_int;
}
pub const sysinit_sub_id_SI_SUB_DUMMY: sysinit_sub_id = 0;
pub const sysinit_sub_id_SI_SUB_DONE: sysinit_sub_id = 1;
pub const sysinit_sub_id_SI_SUB_TUNABLES: sysinit_sub_id = 7340032;
pub const sysinit_sub_id_SI_SUB_COPYRIGHT: sysinit_sub_id = 8388609;
pub const sysinit_sub_id_SI_SUB_VM: sysinit_sub_id = 16777216;
pub const sysinit_sub_id_SI_SUB_COUNTER: sysinit_sub_id = 17825792;
pub const sysinit_sub_id_SI_SUB_KMEM: sysinit_sub_id = 25165824;
pub const sysinit_sub_id_SI_SUB_HYPERVISOR: sysinit_sub_id = 27525120;
pub const sysinit_sub_id_SI_SUB_WITNESS: sysinit_sub_id = 27787264;
pub const sysinit_sub_id_SI_SUB_MTX_POOL_DYNAMIC: sysinit_sub_id = 28049408;
pub const sysinit_sub_id_SI_SUB_LOCK: sysinit_sub_id = 28311552;
pub const sysinit_sub_id_SI_SUB_EVENTHANDLER: sysinit_sub_id = 29360128;
pub const sysinit_sub_id_SI_SUB_VNET_PRELINK: sysinit_sub_id = 31457280;
pub const sysinit_sub_id_SI_SUB_KLD: sysinit_sub_id = 33554432;
pub const sysinit_sub_id_SI_SUB_CPU: sysinit_sub_id = 34603008;
pub const sysinit_sub_id_SI_SUB_RACCT: sysinit_sub_id = 34668544;
pub const sysinit_sub_id_SI_SUB_KDTRACE: sysinit_sub_id = 34865152;
pub const sysinit_sub_id_SI_SUB_RANDOM: sysinit_sub_id = 34996224;
pub const sysinit_sub_id_SI_SUB_MAC: sysinit_sub_id = 35127296;
pub const sysinit_sub_id_SI_SUB_MAC_POLICY: sysinit_sub_id = 35389440;
pub const sysinit_sub_id_SI_SUB_MAC_LATE: sysinit_sub_id = 35454976;
pub const sysinit_sub_id_SI_SUB_VNET: sysinit_sub_id = 35520512;
pub const sysinit_sub_id_SI_SUB_INTRINSIC: sysinit_sub_id = 35651584;
pub const sysinit_sub_id_SI_SUB_VM_CONF: sysinit_sub_id = 36700160;
pub const sysinit_sub_id_SI_SUB_DDB_SERVICES: sysinit_sub_id = 37224448;
pub const sysinit_sub_id_SI_SUB_RUN_QUEUE: sysinit_sub_id = 37748736;
pub const sysinit_sub_id_SI_SUB_KTRACE: sysinit_sub_id = 38273024;
pub const sysinit_sub_id_SI_SUB_OPENSOLARIS: sysinit_sub_id = 38338560;
pub const sysinit_sub_id_SI_SUB_AUDIT: sysinit_sub_id = 38535168;
pub const sysinit_sub_id_SI_SUB_CREATE_INIT: sysinit_sub_id = 38797312;
pub const sysinit_sub_id_SI_SUB_SCHED_IDLE: sysinit_sub_id = 39845888;
pub const sysinit_sub_id_SI_SUB_MBUF: sysinit_sub_id = 40894464;
pub const sysinit_sub_id_SI_SUB_INTR: sysinit_sub_id = 41943040;
pub const sysinit_sub_id_SI_SUB_TASKQ: sysinit_sub_id = 42467328;
pub const sysinit_sub_id_SI_SUB_SOFTINTR: sysinit_sub_id = 44040192;
pub const sysinit_sub_id_SI_SUB_DEVFS: sysinit_sub_id = 49283072;
pub const sysinit_sub_id_SI_SUB_INIT_IF: sysinit_sub_id = 50331648;
pub const sysinit_sub_id_SI_SUB_NETGRAPH: sysinit_sub_id = 50397184;
pub const sysinit_sub_id_SI_SUB_DTRACE: sysinit_sub_id = 50462720;
pub const sysinit_sub_id_SI_SUB_DTRACE_PROVIDER: sysinit_sub_id = 50626560;
pub const sysinit_sub_id_SI_SUB_DTRACE_ANON: sysinit_sub_id = 50905088;
pub const sysinit_sub_id_SI_SUB_DRIVERS: sysinit_sub_id = 51380224;
pub const sysinit_sub_id_SI_SUB_CONFIGURE: sysinit_sub_id = 58720256;
pub const sysinit_sub_id_SI_SUB_VFS: sysinit_sub_id = 67108864;
pub const sysinit_sub_id_SI_SUB_CLOCKS: sysinit_sub_id = 75497472;
pub const sysinit_sub_id_SI_SUB_SYSV_SHM: sysinit_sub_id = 104857600;
pub const sysinit_sub_id_SI_SUB_SYSV_SEM: sysinit_sub_id = 109051904;
pub const sysinit_sub_id_SI_SUB_SYSV_MSG: sysinit_sub_id = 113246208;
pub const sysinit_sub_id_SI_SUB_P1003_1B: sysinit_sub_id = 115343360;
pub const sysinit_sub_id_SI_SUB_PSEUDO: sysinit_sub_id = 117440512;
pub const sysinit_sub_id_SI_SUB_EXEC: sysinit_sub_id = 121634816;
pub const sysinit_sub_id_SI_SUB_PROTO_BEGIN: sysinit_sub_id = 134217728;
pub const sysinit_sub_id_SI_SUB_PROTO_PFIL: sysinit_sub_id = 135266304;
pub const sysinit_sub_id_SI_SUB_PROTO_IF: sysinit_sub_id = 138412032;
pub const sysinit_sub_id_SI_SUB_PROTO_DOMAININIT: sysinit_sub_id = 140509184;
pub const sysinit_sub_id_SI_SUB_PROTO_MC: sysinit_sub_id = 141557760;
pub const sysinit_sub_id_SI_SUB_PROTO_DOMAIN: sysinit_sub_id = 142606336;
pub const sysinit_sub_id_SI_SUB_PROTO_FIREWALL: sysinit_sub_id = 142630912;
pub const sysinit_sub_id_SI_SUB_PROTO_IFATTACHDOMAIN: sysinit_sub_id = 142639104;
pub const sysinit_sub_id_SI_SUB_PROTO_END: sysinit_sub_id = 150994943;
pub const sysinit_sub_id_SI_SUB_KPROF: sysinit_sub_id = 150994944;
pub const sysinit_sub_id_SI_SUB_KICK_SCHEDULER: sysinit_sub_id = 167772160;
pub const sysinit_sub_id_SI_SUB_INT_CONFIG_HOOKS: sysinit_sub_id = 176160768;
pub const sysinit_sub_id_SI_SUB_ROOT_CONF: sysinit_sub_id = 184549376;
pub const sysinit_sub_id_SI_SUB_INTRINSIC_POST: sysinit_sub_id = 218103808;
pub const sysinit_sub_id_SI_SUB_SYSCALLS: sysinit_sub_id = 226492416;
pub const sysinit_sub_id_SI_SUB_VNET_DONE: sysinit_sub_id = 230686720;
pub const sysinit_sub_id_SI_SUB_KTHREAD_INIT: sysinit_sub_id = 234881024;
pub const sysinit_sub_id_SI_SUB_KTHREAD_PAGE: sysinit_sub_id = 239075328;
pub const sysinit_sub_id_SI_SUB_KTHREAD_VM: sysinit_sub_id = 243269632;
pub const sysinit_sub_id_SI_SUB_KTHREAD_BUF: sysinit_sub_id = 245366784;
pub const sysinit_sub_id_SI_SUB_KTHREAD_UPDATE: sysinit_sub_id = 247463936;
pub const sysinit_sub_id_SI_SUB_KTHREAD_IDLE: sysinit_sub_id = 249561088;
pub const sysinit_sub_id_SI_SUB_SMP: sysinit_sub_id = 251658240;
pub const sysinit_sub_id_SI_SUB_RACCTD: sysinit_sub_id = 252706816;
pub const sysinit_sub_id_SI_SUB_LAST: sysinit_sub_id = 268435455;
pub type sysinit_sub_id = cty::c_uint;
pub const sysinit_elem_order_SI_ORDER_FIRST: sysinit_elem_order = 0;
pub const sysinit_elem_order_SI_ORDER_SECOND: sysinit_elem_order = 1;
pub const sysinit_elem_order_SI_ORDER_THIRD: sysinit_elem_order = 2;
pub const sysinit_elem_order_SI_ORDER_FOURTH: sysinit_elem_order = 3;
pub const sysinit_elem_order_SI_ORDER_FIFTH: sysinit_elem_order = 4;
pub const sysinit_elem_order_SI_ORDER_SIXTH: sysinit_elem_order = 5;
pub const sysinit_elem_order_SI_ORDER_SEVENTH: sysinit_elem_order = 6;
pub const sysinit_elem_order_SI_ORDER_EIGHTH: sysinit_elem_order = 7;
pub const sysinit_elem_order_SI_ORDER_MIDDLE: sysinit_elem_order = 16777216;
pub const sysinit_elem_order_SI_ORDER_ANY: sysinit_elem_order = 268435455;
pub type sysinit_elem_order = cty::c_uint;
pub type sysinit_nfunc_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
pub type sysinit_cfunc_t = ::core::option::Option<unsafe extern "C" fn(arg1: *const cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sysinit {
    pub subsystem: sysinit_sub_id,
    pub order: sysinit_elem_order,
    pub func: sysinit_cfunc_t,
    pub udata: *const cty::c_void,
}
#[test]
fn bindgen_test_layout_sysinit() {
    assert_eq!(
        ::core::mem::size_of::<sysinit>(),
        24usize,
        concat!("Size of: ", stringify!(sysinit))
    );
    assert_eq!(
        ::core::mem::align_of::<sysinit>(),
        8usize,
        concat!("Alignment of ", stringify!(sysinit))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysinit>())).subsystem as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinit),
            "::",
            stringify!(subsystem)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysinit>())).order as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinit),
            "::",
            stringify!(order)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysinit>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinit),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sysinit>())).udata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sysinit),
            "::",
            stringify!(udata)
        )
    );
}
extern "C" {
    pub fn sysinit_add(set: *mut *mut sysinit, set_end: *mut *mut sysinit);
}
extern "C" {
    pub fn tunable_int_init(arg1: *mut cty::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tunable_int {
    pub path: *const cty::c_char,
    pub var: *mut cty::c_int,
}
#[test]
fn bindgen_test_layout_tunable_int() {
    assert_eq!(
        ::core::mem::size_of::<tunable_int>(),
        16usize,
        concat!("Size of: ", stringify!(tunable_int))
    );
    assert_eq!(
        ::core::mem::align_of::<tunable_int>(),
        8usize,
        concat!("Alignment of ", stringify!(tunable_int))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tunable_int>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tunable_int),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tunable_int>())).var as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tunable_int),
            "::",
            stringify!(var)
        )
    );
}
extern "C" {
    pub fn tunable_long_init(arg1: *mut cty::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tunable_long {
    pub path: *const cty::c_char,
    pub var: *mut cty::c_long,
}
#[test]
fn bindgen_test_layout_tunable_long() {
    assert_eq!(
        ::core::mem::size_of::<tunable_long>(),
        16usize,
        concat!("Size of: ", stringify!(tunable_long))
    );
    assert_eq!(
        ::core::mem::align_of::<tunable_long>(),
        8usize,
        concat!("Alignment of ", stringify!(tunable_long))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tunable_long>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tunable_long),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tunable_long>())).var as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tunable_long),
            "::",
            stringify!(var)
        )
    );
}
extern "C" {
    pub fn tunable_ulong_init(arg1: *mut cty::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tunable_ulong {
    pub path: *const cty::c_char,
    pub var: *mut cty::c_ulong,
}
#[test]
fn bindgen_test_layout_tunable_ulong() {
    assert_eq!(
        ::core::mem::size_of::<tunable_ulong>(),
        16usize,
        concat!("Size of: ", stringify!(tunable_ulong))
    );
    assert_eq!(
        ::core::mem::align_of::<tunable_ulong>(),
        8usize,
        concat!("Alignment of ", stringify!(tunable_ulong))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tunable_ulong>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tunable_ulong),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tunable_ulong>())).var as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tunable_ulong),
            "::",
            stringify!(var)
        )
    );
}
extern "C" {
    pub fn tunable_int64_init(arg1: *mut cty::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tunable_int64 {
    pub path: *const cty::c_char,
    pub var: *mut i64,
}
#[test]
fn bindgen_test_layout_tunable_int64() {
    assert_eq!(
        ::core::mem::size_of::<tunable_int64>(),
        16usize,
        concat!("Size of: ", stringify!(tunable_int64))
    );
    assert_eq!(
        ::core::mem::align_of::<tunable_int64>(),
        8usize,
        concat!("Alignment of ", stringify!(tunable_int64))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tunable_int64>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tunable_int64),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tunable_int64>())).var as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tunable_int64),
            "::",
            stringify!(var)
        )
    );
}
extern "C" {
    pub fn tunable_uint64_init(arg1: *mut cty::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tunable_uint64 {
    pub path: *const cty::c_char,
    pub var: *mut u64,
}
#[test]
fn bindgen_test_layout_tunable_uint64() {
    assert_eq!(
        ::core::mem::size_of::<tunable_uint64>(),
        16usize,
        concat!("Size of: ", stringify!(tunable_uint64))
    );
    assert_eq!(
        ::core::mem::align_of::<tunable_uint64>(),
        8usize,
        concat!("Alignment of ", stringify!(tunable_uint64))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tunable_uint64>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tunable_uint64),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tunable_uint64>())).var as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tunable_uint64),
            "::",
            stringify!(var)
        )
    );
}
extern "C" {
    pub fn tunable_quad_init(arg1: *mut cty::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tunable_quad {
    pub path: *const cty::c_char,
    pub var: *mut quad_t,
}
#[test]
fn bindgen_test_layout_tunable_quad() {
    assert_eq!(
        ::core::mem::size_of::<tunable_quad>(),
        16usize,
        concat!("Size of: ", stringify!(tunable_quad))
    );
    assert_eq!(
        ::core::mem::align_of::<tunable_quad>(),
        8usize,
        concat!("Alignment of ", stringify!(tunable_quad))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tunable_quad>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tunable_quad),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tunable_quad>())).var as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tunable_quad),
            "::",
            stringify!(var)
        )
    );
}
extern "C" {
    pub fn tunable_str_init(arg1: *mut cty::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tunable_str {
    pub path: *const cty::c_char,
    pub var: *mut cty::c_char,
    pub size: cty::c_int,
}
#[test]
fn bindgen_test_layout_tunable_str() {
    assert_eq!(
        ::core::mem::size_of::<tunable_str>(),
        24usize,
        concat!("Size of: ", stringify!(tunable_str))
    );
    assert_eq!(
        ::core::mem::align_of::<tunable_str>(),
        8usize,
        concat!("Alignment of ", stringify!(tunable_str))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tunable_str>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tunable_str),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tunable_str>())).var as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tunable_str),
            "::",
            stringify!(var)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tunable_str>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tunable_str),
            "::",
            stringify!(size)
        )
    );
}
pub type ich_func_t = ::core::option::Option<unsafe extern "C" fn(_arg: *mut cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct intr_config_hook {
    pub ich_links: intr_config_hook__bindgen_ty_1,
    pub ich_func: ich_func_t,
    pub ich_arg: *mut cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct intr_config_hook__bindgen_ty_1 {
    pub tqe_next: *mut intr_config_hook,
    pub tqe_prev: *mut *mut intr_config_hook,
}
#[test]
fn bindgen_test_layout_intr_config_hook__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<intr_config_hook__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(intr_config_hook__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<intr_config_hook__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(intr_config_hook__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<intr_config_hook__bindgen_ty_1>())).tqe_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(intr_config_hook__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<intr_config_hook__bindgen_ty_1>())).tqe_prev as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(intr_config_hook__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_intr_config_hook() {
    assert_eq!(
        ::core::mem::size_of::<intr_config_hook>(),
        32usize,
        concat!("Size of: ", stringify!(intr_config_hook))
    );
    assert_eq!(
        ::core::mem::align_of::<intr_config_hook>(),
        8usize,
        concat!("Alignment of ", stringify!(intr_config_hook))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<intr_config_hook>())).ich_links as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(intr_config_hook),
            "::",
            stringify!(ich_links)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<intr_config_hook>())).ich_func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(intr_config_hook),
            "::",
            stringify!(ich_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<intr_config_hook>())).ich_arg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(intr_config_hook),
            "::",
            stringify!(ich_arg)
        )
    );
}
extern "C" {
    pub fn config_intrhook_establish(hook: *mut intr_config_hook) -> cty::c_int;
}
extern "C" {
    pub fn config_intrhook_disestablish(hook: *mut intr_config_hook);
}
extern "C" {
    pub fn config_intrhook_oneshot(_func: ich_func_t, _arg: *mut cty::c_void);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_list_entry {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_class {
    pub lc_name: *const cty::c_char,
    pub lc_flags: u_int,
    pub lc_assert:
        ::core::option::Option<unsafe extern "C" fn(lock: *const lock_object, what: cty::c_int)>,
    pub lc_ddb_show: ::core::option::Option<unsafe extern "C" fn(lock: *const lock_object)>,
    pub lc_lock: ::core::option::Option<unsafe extern "C" fn(lock: *mut lock_object, how: usize)>,
    pub lc_owner: ::core::option::Option<
        unsafe extern "C" fn(lock: *const lock_object, owner: *mut *mut thread) -> cty::c_int,
    >,
    pub lc_unlock: ::core::option::Option<unsafe extern "C" fn(lock: *mut lock_object) -> usize>,
}
#[test]
fn bindgen_test_layout_lock_class() {
    assert_eq!(
        ::core::mem::size_of::<lock_class>(),
        56usize,
        concat!("Size of: ", stringify!(lock_class))
    );
    assert_eq!(
        ::core::mem::align_of::<lock_class>(),
        8usize,
        concat!("Alignment of ", stringify!(lock_class))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lock_class>())).lc_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_class),
            "::",
            stringify!(lc_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lock_class>())).lc_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_class),
            "::",
            stringify!(lc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lock_class>())).lc_assert as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_class),
            "::",
            stringify!(lc_assert)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lock_class>())).lc_ddb_show as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_class),
            "::",
            stringify!(lc_ddb_show)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lock_class>())).lc_lock as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_class),
            "::",
            stringify!(lc_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lock_class>())).lc_owner as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_class),
            "::",
            stringify!(lc_owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lock_class>())).lc_unlock as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_class),
            "::",
            stringify!(lc_unlock)
        )
    );
}
extern "C" {
    pub static mut lock_class_mtx_sleep: lock_class;
}
extern "C" {
    pub static mut lock_class_mtx_spin: lock_class;
}
extern "C" {
    pub static mut lock_class_sx: lock_class;
}
extern "C" {
    pub static mut lock_class_rw: lock_class;
}
extern "C" {
    pub static mut lock_class_rm: lock_class;
}
extern "C" {
    pub static mut lock_class_rm_sleepable: lock_class;
}
extern "C" {
    pub static mut lock_class_lockmgr: lock_class;
}
extern "C" {
    pub static mut lock_classes: [*mut lock_class; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_delay_config {
    pub base: u_int,
    pub max: u_int,
}
#[test]
fn bindgen_test_layout_lock_delay_config() {
    assert_eq!(
        ::core::mem::size_of::<lock_delay_config>(),
        8usize,
        concat!("Size of: ", stringify!(lock_delay_config))
    );
    assert_eq!(
        ::core::mem::align_of::<lock_delay_config>(),
        4usize,
        concat!("Alignment of ", stringify!(lock_delay_config))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lock_delay_config>())).base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_delay_config),
            "::",
            stringify!(base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lock_delay_config>())).max as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_delay_config),
            "::",
            stringify!(max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_delay_arg {
    pub config: *mut lock_delay_config,
    pub delay: u_int,
    pub spin_cnt: u_int,
}
#[test]
fn bindgen_test_layout_lock_delay_arg() {
    assert_eq!(
        ::core::mem::size_of::<lock_delay_arg>(),
        16usize,
        concat!("Size of: ", stringify!(lock_delay_arg))
    );
    assert_eq!(
        ::core::mem::align_of::<lock_delay_arg>(),
        8usize,
        concat!("Alignment of ", stringify!(lock_delay_arg))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lock_delay_arg>())).config as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_delay_arg),
            "::",
            stringify!(config)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lock_delay_arg>())).delay as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_delay_arg),
            "::",
            stringify!(delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lock_delay_arg>())).spin_cnt as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(lock_delay_arg),
            "::",
            stringify!(spin_cnt)
        )
    );
}
extern "C" {
    pub fn lock_init(
        arg1: *mut lock_object,
        arg2: *mut lock_class,
        arg3: *const cty::c_char,
        arg4: *const cty::c_char,
        arg5: cty::c_int,
    );
}
extern "C" {
    pub fn lock_destroy(arg1: *mut lock_object);
}
extern "C" {
    pub fn lock_delay(arg1: *mut lock_delay_arg);
}
extern "C" {
    pub fn lock_delay_default_init(arg1: *mut lock_delay_config);
}
extern "C" {
    pub fn spinlock_enter();
}
extern "C" {
    pub fn spinlock_exit();
}
extern "C" {
    pub fn witness_init(arg1: *mut lock_object, arg2: *const cty::c_char);
}
extern "C" {
    pub fn witness_destroy(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_defineorder(arg1: *mut lock_object, arg2: *mut lock_object) -> cty::c_int;
}
extern "C" {
    pub fn witness_checkorder(
        arg1: *mut lock_object,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: cty::c_int,
        arg5: *mut lock_object,
    );
}
extern "C" {
    pub fn witness_lock(
        arg1: *mut lock_object,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: cty::c_int,
    );
}
extern "C" {
    pub fn witness_upgrade(
        arg1: *mut lock_object,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: cty::c_int,
    );
}
extern "C" {
    pub fn witness_downgrade(
        arg1: *mut lock_object,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: cty::c_int,
    );
}
extern "C" {
    pub fn witness_unlock(
        arg1: *mut lock_object,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: cty::c_int,
    );
}
extern "C" {
    pub fn witness_save(
        arg1: *mut lock_object,
        arg2: *mut *const cty::c_char,
        arg3: *mut cty::c_int,
    );
}
extern "C" {
    pub fn witness_restore(arg1: *mut lock_object, arg2: *const cty::c_char, arg3: cty::c_int);
}
extern "C" {
    pub fn witness_list_locks(
        arg1: *mut *mut lock_list_entry,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const cty::c_char, ...) -> cty::c_int,
        >,
    ) -> cty::c_int;
}
extern "C" {
    pub fn witness_warn(
        arg1: cty::c_int,
        arg2: *mut lock_object,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn witness_assert(
        arg1: *const lock_object,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: cty::c_int,
    );
}
extern "C" {
    pub fn witness_display_spinlock(
        arg1: *mut lock_object,
        arg2: *mut thread,
        arg3: ::core::option::Option<
            unsafe extern "C" fn(arg1: *const cty::c_char, ...) -> cty::c_int,
        >,
    );
}
extern "C" {
    pub fn witness_line(arg1: *mut lock_object) -> cty::c_int;
}
extern "C" {
    pub fn witness_norelease(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_releaseok(arg1: *mut lock_object);
}
extern "C" {
    pub fn witness_file(arg1: *mut lock_object) -> *const cty::c_char;
}
extern "C" {
    pub fn witness_thread_exit(arg1: *mut thread);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ktr_entry {
    pub ktr_timestamp: u_int64_t,
    pub ktr_cpu: cty::c_int,
    pub ktr_line: cty::c_int,
    pub ktr_file: *const cty::c_char,
    pub ktr_desc: *const cty::c_char,
    pub ktr_thread: *mut thread,
    pub ktr_parms: [u_long; 6usize],
}
#[test]
fn bindgen_test_layout_ktr_entry() {
    assert_eq!(
        ::core::mem::size_of::<ktr_entry>(),
        88usize,
        concat!("Size of: ", stringify!(ktr_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<ktr_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(ktr_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ktr_entry>())).ktr_timestamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ktr_entry),
            "::",
            stringify!(ktr_timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ktr_entry>())).ktr_cpu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ktr_entry),
            "::",
            stringify!(ktr_cpu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ktr_entry>())).ktr_line as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ktr_entry),
            "::",
            stringify!(ktr_line)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ktr_entry>())).ktr_file as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ktr_entry),
            "::",
            stringify!(ktr_file)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ktr_entry>())).ktr_desc as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ktr_entry),
            "::",
            stringify!(ktr_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ktr_entry>())).ktr_thread as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ktr_entry),
            "::",
            stringify!(ktr_thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ktr_entry>())).ktr_parms as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ktr_entry),
            "::",
            stringify!(ktr_parms)
        )
    );
}
extern "C" {
    pub static mut ktr_cpumask: cpuset_t;
}
extern "C" {
    pub static mut ktr_mask: u64;
}
extern "C" {
    pub static mut ktr_entries: cty::c_int;
}
extern "C" {
    pub static mut ktr_verbose: cty::c_int;
}
extern "C" {
    pub static mut ktr_idx: cty::c_int;
}
extern "C" {
    pub static mut ktr_buf: *mut ktr_entry;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lock_profile_object {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lpohead {
    pub lh_first: *mut lock_profile_object,
}
#[test]
fn bindgen_test_layout_lpohead() {
    assert_eq!(
        ::core::mem::size_of::<lpohead>(),
        8usize,
        concat!("Size of: ", stringify!(lpohead))
    );
    assert_eq!(
        ::core::mem::align_of::<lpohead>(),
        8usize,
        concat!("Alignment of ", stringify!(lpohead))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lpohead>())).lh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lpohead),
            "::",
            stringify!(lh_first)
        )
    );
}
extern "C" {
    pub static mut sdt_probes_enabled: bool_;
}
pub type sdt_probe_func_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: u32,
        arg0: usize,
        arg1: usize,
        arg2: usize,
        arg3: usize,
        arg4: usize,
    ),
>;
extern "C" {
    pub static mut sdt_probe_func: sdt_probe_func_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdt_argtype {
    pub ndx: cty::c_int,
    pub type_: *const cty::c_char,
    pub xtype: *const cty::c_char,
    pub argtype_entry: sdt_argtype__bindgen_ty_1,
    pub probe: *mut sdt_probe,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdt_argtype__bindgen_ty_1 {
    pub tqe_next: *mut sdt_argtype,
    pub tqe_prev: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_argtype__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sdt_argtype__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(sdt_argtype__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sdt_argtype__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sdt_argtype__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sdt_argtype__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_argtype__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sdt_argtype__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_argtype__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_sdt_argtype() {
    assert_eq!(
        ::core::mem::size_of::<sdt_argtype>(),
        48usize,
        concat!("Size of: ", stringify!(sdt_argtype))
    );
    assert_eq!(
        ::core::mem::align_of::<sdt_argtype>(),
        8usize,
        concat!("Alignment of ", stringify!(sdt_argtype))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_argtype>())).ndx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_argtype),
            "::",
            stringify!(ndx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_argtype>())).type_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_argtype),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_argtype>())).xtype as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_argtype),
            "::",
            stringify!(xtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_argtype>())).argtype_entry as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_argtype),
            "::",
            stringify!(argtype_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_argtype>())).probe as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_argtype),
            "::",
            stringify!(probe)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdt_probe {
    pub version: cty::c_int,
    pub prov: *mut sdt_provider,
    pub probe_entry: sdt_probe__bindgen_ty_1,
    pub argtype_list: sdt_probe__bindgen_ty_2,
    pub mod_: *const cty::c_char,
    pub func: *const cty::c_char,
    pub name: *const cty::c_char,
    pub id: id_t,
    pub n_args: cty::c_int,
    pub sdtp_lf: *mut linker_file,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdt_probe__bindgen_ty_1 {
    pub tqe_next: *mut sdt_probe,
    pub tqe_prev: *mut *mut sdt_probe,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sdt_probe__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(sdt_probe__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sdt_probe__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sdt_probe__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sdt_probe__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_probe__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sdt_probe__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_probe__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdt_probe__bindgen_ty_2 {
    pub tqh_first: *mut sdt_argtype,
    pub tqh_last: *mut *mut sdt_argtype,
}
#[test]
fn bindgen_test_layout_sdt_probe__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<sdt_probe__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(sdt_probe__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<sdt_probe__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(sdt_probe__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sdt_probe__bindgen_ty_2>())).tqh_first as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_probe__bindgen_ty_2),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sdt_probe__bindgen_ty_2>())).tqh_last as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_probe__bindgen_ty_2),
            "::",
            stringify!(tqh_last)
        )
    );
}
#[test]
fn bindgen_test_layout_sdt_probe() {
    assert_eq!(
        ::core::mem::size_of::<sdt_probe>(),
        96usize,
        concat!("Size of: ", stringify!(sdt_probe))
    );
    assert_eq!(
        ::core::mem::align_of::<sdt_probe>(),
        8usize,
        concat!("Alignment of ", stringify!(sdt_probe))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_probe>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_probe),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_probe>())).prov as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_probe),
            "::",
            stringify!(prov)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_probe>())).probe_entry as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_probe),
            "::",
            stringify!(probe_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_probe>())).argtype_list as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_probe),
            "::",
            stringify!(argtype_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_probe>())).mod_ as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_probe),
            "::",
            stringify!(mod_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_probe>())).func as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_probe),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_probe>())).name as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_probe),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_probe>())).id as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_probe),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_probe>())).n_args as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_probe),
            "::",
            stringify!(n_args)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_probe>())).sdtp_lf as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_probe),
            "::",
            stringify!(sdtp_lf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdt_provider {
    pub name: *mut cty::c_char,
    pub prov_entry: sdt_provider__bindgen_ty_1,
    pub id: usize,
    pub sdt_refs: cty::c_int,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sdt_provider__bindgen_ty_1 {
    pub tqe_next: *mut sdt_provider,
    pub tqe_prev: *mut *mut sdt_provider,
}
#[test]
fn bindgen_test_layout_sdt_provider__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<sdt_provider__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(sdt_provider__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<sdt_provider__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(sdt_provider__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sdt_provider__bindgen_ty_1>())).tqe_next as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_provider__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<sdt_provider__bindgen_ty_1>())).tqe_prev as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_provider__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_sdt_provider() {
    assert_eq!(
        ::core::mem::size_of::<sdt_provider>(),
        40usize,
        concat!("Size of: ", stringify!(sdt_provider))
    );
    assert_eq!(
        ::core::mem::align_of::<sdt_provider>(),
        8usize,
        concat!("Alignment of ", stringify!(sdt_provider))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_provider>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_provider),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_provider>())).prov_entry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_provider),
            "::",
            stringify!(prov_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_provider>())).id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_provider),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sdt_provider>())).sdt_refs as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(sdt_provider),
            "::",
            stringify!(sdt_refs)
        )
    );
}
extern "C" {
    pub fn sdt_probe_stub(
        arg1: u32,
        arg2: usize,
        arg3: usize,
        arg4: usize,
        arg5: usize,
        arg6: usize,
    );
}
extern "C" {
    pub static mut lockstat_enabled: bool_;
}
extern "C" {
    pub fn _mtx_init(
        c: *mut usize,
        name: *const cty::c_char,
        type_: *const cty::c_char,
        opts: cty::c_int,
    );
}
extern "C" {
    pub fn _mtx_destroy(c: *mut usize);
}
extern "C" {
    pub fn mtx_sysinit(arg: *mut cty::c_void);
}
extern "C" {
    pub fn _mtx_trylock_flags_int(
        m: *mut mtx,
        opts: cty::c_int,
        file: *const cty::c_char,
        line: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _mtx_trylock_flags_(
        c: *mut usize,
        opts: cty::c_int,
        file: *const cty::c_char,
        line: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn mutex_init();
}
extern "C" {
    pub fn __mtx_lock_sleep(
        c: *mut usize,
        v: usize,
        opts: cty::c_int,
        file: *const cty::c_char,
        line: cty::c_int,
    );
}
extern "C" {
    pub fn __mtx_unlock_sleep(
        c: *mut usize,
        v: usize,
        opts: cty::c_int,
        file: *const cty::c_char,
        line: cty::c_int,
    );
}
extern "C" {
    pub fn __mtx_lock_flags(
        c: *mut usize,
        opts: cty::c_int,
        file: *const cty::c_char,
        line: cty::c_int,
    );
}
extern "C" {
    pub fn __mtx_unlock_flags(
        c: *mut usize,
        opts: cty::c_int,
        file: *const cty::c_char,
        line: cty::c_int,
    );
}
extern "C" {
    pub fn __mtx_lock_spin_flags(
        c: *mut usize,
        opts: cty::c_int,
        file: *const cty::c_char,
        line: cty::c_int,
    );
}
extern "C" {
    pub fn __mtx_trylock_spin_flags(
        c: *mut usize,
        opts: cty::c_int,
        file: *const cty::c_char,
        line: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn __mtx_unlock_spin_flags(
        c: *mut usize,
        opts: cty::c_int,
        file: *const cty::c_char,
        line: cty::c_int,
    );
}
extern "C" {
    pub fn mtx_spin_wait_unlocked(m: *mut mtx);
}
extern "C" {
    pub fn thread_lock_flags_(
        arg1: *mut thread,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: cty::c_int,
    );
}
extern "C" {
    pub fn _thread_lock(
        td: *mut thread,
        opts: cty::c_int,
        file: *const cty::c_char,
        line: cty::c_int,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtx_pool {
    _unused: [u8; 0],
}
extern "C" {
    pub fn mtx_pool_create(
        mtx_name: *const cty::c_char,
        pool_size: cty::c_int,
        opts: cty::c_int,
    ) -> *mut mtx_pool;
}
extern "C" {
    pub fn mtx_pool_destroy(poolp: *mut *mut mtx_pool);
}
extern "C" {
    pub fn mtx_pool_find(pool: *mut mtx_pool, ptr: *mut cty::c_void) -> *mut mtx;
}
extern "C" {
    pub fn mtx_pool_alloc(pool: *mut mtx_pool) -> *mut mtx;
}
extern "C" {
    pub static mut mtxpool_sleep: *mut mtx_pool;
}
extern "C" {
    pub static mut Giant: mtx;
}
extern "C" {
    pub static mut blocked_lock: mtx;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mtx_args {
    pub ma_mtx: *mut cty::c_void,
    pub ma_desc: *const cty::c_char,
    pub ma_opts: cty::c_int,
}
#[test]
fn bindgen_test_layout_mtx_args() {
    assert_eq!(
        ::core::mem::size_of::<mtx_args>(),
        24usize,
        concat!("Size of: ", stringify!(mtx_args))
    );
    assert_eq!(
        ::core::mem::align_of::<mtx_args>(),
        8usize,
        concat!("Alignment of ", stringify!(mtx_args))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mtx_args>())).ma_mtx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mtx_args),
            "::",
            stringify!(ma_mtx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mtx_args>())).ma_desc as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mtx_args),
            "::",
            stringify!(ma_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mtx_args>())).ma_opts as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mtx_args),
            "::",
            stringify!(ma_opts)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry {
    pub ee_link: eventhandler_entry__bindgen_ty_1,
    pub ee_priority: cty::c_int,
    pub ee_arg: *mut cty::c_void,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_entry,
    pub tqe_prev: *mut *mut eventhandler_entry,
}
#[test]
fn bindgen_test_layout_eventhandler_entry__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(eventhandler_entry__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry__bindgen_ty_1>())).tqe_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry__bindgen_ty_1>())).tqe_prev as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[test]
fn bindgen_test_layout_eventhandler_entry() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry>(),
        32usize,
        concat!("Size of: ", stringify!(eventhandler_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<eventhandler_entry>())).ee_link as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry),
            "::",
            stringify!(ee_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<eventhandler_entry>())).ee_priority as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry),
            "::",
            stringify!(ee_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<eventhandler_entry>())).ee_arg as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry),
            "::",
            stringify!(ee_arg)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_list {
    pub el_name: *mut cty::c_char,
    pub el_flags: cty::c_int,
    pub el_runcount: u_int,
    pub el_lock: mtx,
    pub el_link: eventhandler_list__bindgen_ty_1,
    pub el_entries: eventhandler_list__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_list__bindgen_ty_1 {
    pub tqe_next: *mut eventhandler_list,
    pub tqe_prev: *mut *mut eventhandler_list,
}
#[test]
fn bindgen_test_layout_eventhandler_list__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_list__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(eventhandler_list__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_list__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_list__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_list__bindgen_ty_1>())).tqe_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_list__bindgen_ty_1),
            "::",
            stringify!(tqe_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_list__bindgen_ty_1>())).tqe_prev as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_list__bindgen_ty_1),
            "::",
            stringify!(tqe_prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_list__bindgen_ty_2 {
    pub tqh_first: *mut eventhandler_entry,
    pub tqh_last: *mut *mut eventhandler_entry,
}
#[test]
fn bindgen_test_layout_eventhandler_list__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_list__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(eventhandler_list__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_list__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_list__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_list__bindgen_ty_2>())).tqh_first as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_list__bindgen_ty_2),
            "::",
            stringify!(tqh_first)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_list__bindgen_ty_2>())).tqh_last as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_list__bindgen_ty_2),
            "::",
            stringify!(tqh_last)
        )
    );
}
#[test]
fn bindgen_test_layout_eventhandler_list() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_list>(),
        80usize,
        concat!("Size of: ", stringify!(eventhandler_list))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_list>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<eventhandler_list>())).el_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_list),
            "::",
            stringify!(el_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<eventhandler_list>())).el_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_list),
            "::",
            stringify!(el_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<eventhandler_list>())).el_runcount as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_list),
            "::",
            stringify!(el_runcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<eventhandler_list>())).el_lock as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_list),
            "::",
            stringify!(el_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<eventhandler_list>())).el_link as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_list),
            "::",
            stringify!(el_link)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<eventhandler_list>())).el_entries as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_list),
            "::",
            stringify!(el_entries)
        )
    );
}
pub type eventhandler_tag = *mut eventhandler_entry;
extern "C" {
    pub fn eventhandler_register(
        list: *mut eventhandler_list,
        name: *const cty::c_char,
        func: *mut cty::c_void,
        arg: *mut cty::c_void,
        priority: cty::c_int,
    ) -> eventhandler_tag;
}
extern "C" {
    pub fn eventhandler_deregister(list: *mut eventhandler_list, tag: eventhandler_tag);
}
extern "C" {
    pub fn eventhandler_deregister_nowait(list: *mut eventhandler_list, tag: eventhandler_tag);
}
extern "C" {
    pub fn eventhandler_find_list(name: *const cty::c_char) -> *mut eventhandler_list;
}
extern "C" {
    pub fn eventhandler_prune_list(list: *mut eventhandler_list);
}
extern "C" {
    pub fn eventhandler_create_list(name: *const cty::c_char) -> *mut eventhandler_list;
}
pub type shutdown_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: cty::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_shutdown_pre_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_pre_sync() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_shutdown_pre_sync>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(eventhandler_entry_shutdown_pre_sync)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_shutdown_pre_sync>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_shutdown_pre_sync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_shutdown_pre_sync>())).ee as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_shutdown_pre_sync),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_shutdown_pre_sync>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_shutdown_pre_sync),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_shutdown_post_sync {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_post_sync() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_shutdown_post_sync>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(eventhandler_entry_shutdown_post_sync)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_shutdown_post_sync>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_shutdown_post_sync)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_shutdown_post_sync>())).ee as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_shutdown_post_sync),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_shutdown_post_sync>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_shutdown_post_sync),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_shutdown_final {
    pub ee: eventhandler_entry,
    pub eh_func: shutdown_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_shutdown_final() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_shutdown_final>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_shutdown_final))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_shutdown_final>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_shutdown_final)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_shutdown_final>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_shutdown_final),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_shutdown_final>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_shutdown_final),
            "::",
            stringify!(eh_func)
        )
    );
}
pub type power_change_fn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_power_resume {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_resume() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_power_resume>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_power_resume))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_power_resume>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_power_resume))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_power_resume>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_power_resume),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_power_resume>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_power_resume),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_power_suspend {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_suspend() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_power_suspend>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_power_suspend))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_power_suspend>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_power_suspend)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_power_suspend>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_power_suspend),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_power_suspend>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_power_suspend),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_power_suspend_early {
    pub ee: eventhandler_entry,
    pub eh_func: power_change_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_power_suspend_early() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_power_suspend_early>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(eventhandler_entry_power_suspend_early)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_power_suspend_early>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_power_suspend_early)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_power_suspend_early>())).ee as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_power_suspend_early),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_power_suspend_early>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_power_suspend_early),
            "::",
            stringify!(eh_func)
        )
    );
}
pub type vm_lowmem_handler_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: cty::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_vm_lowmem {
    pub ee: eventhandler_entry,
    pub eh_func: vm_lowmem_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vm_lowmem() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_vm_lowmem>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_vm_lowmem))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_vm_lowmem>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_vm_lowmem))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_vm_lowmem>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_vm_lowmem),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_vm_lowmem>())).eh_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_vm_lowmem),
            "::",
            stringify!(eh_func)
        )
    );
}
pub type mountroot_handler_t = ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_mountroot {
    pub ee: eventhandler_entry,
    pub eh_func: mountroot_handler_t,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_mountroot() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_mountroot>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_mountroot))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_mountroot>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_mountroot))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_mountroot>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_mountroot),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_mountroot>())).eh_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_mountroot),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mount {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vnode {
    _unused: [u8; 0],
}
pub type vfs_mounted_notify_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut cty::c_void,
        arg2: *mut mount,
        arg3: *mut vnode,
        arg4: *mut thread,
    ),
>;
pub type vfs_unmounted_notify_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut mount, arg3: *mut thread),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_vfs_mounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_mounted_notify_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vfs_mounted() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_vfs_mounted>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_vfs_mounted))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_vfs_mounted>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_vfs_mounted))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_vfs_mounted>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_vfs_mounted),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_vfs_mounted>())).eh_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_vfs_mounted),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_vfs_unmounted {
    pub ee: eventhandler_entry,
    pub eh_func: vfs_unmounted_notify_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_vfs_unmounted() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_vfs_unmounted>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_vfs_unmounted))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_vfs_unmounted>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_vfs_unmounted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_vfs_unmounted>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_vfs_unmounted),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_vfs_unmounted>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_vfs_unmounted),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct image_params {
    _unused: [u8; 0],
}
pub type exitlist_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut proc_)>;
pub type forklist_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut cty::c_void,
        arg2: *mut proc_,
        arg3: *mut proc_,
        arg4: cty::c_int,
    ),
>;
pub type execlist_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut proc_, arg3: *mut image_params),
>;
pub type proc_ctor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut proc_)>;
pub type proc_dtor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut proc_)>;
pub type proc_init_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut proc_)>;
pub type proc_fini_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut proc_)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_process_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_ctor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_ctor() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_process_ctor>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_process_ctor))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_process_ctor>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_process_ctor))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_process_ctor>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_process_ctor),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_process_ctor>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_process_ctor),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_process_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: proc_dtor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_dtor() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_process_dtor>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_process_dtor))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_process_dtor>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_process_dtor))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_process_dtor>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_process_dtor),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_process_dtor>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_process_dtor),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_process_init {
    pub ee: eventhandler_entry,
    pub eh_func: proc_init_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_init() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_process_init>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_process_init))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_process_init>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_process_init))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_process_init>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_process_init),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_process_init>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_process_init),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_process_fini {
    pub ee: eventhandler_entry,
    pub eh_func: proc_fini_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_fini() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_process_fini>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_process_fini))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_process_fini>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_process_fini))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_process_fini>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_process_fini),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_process_fini>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_process_fini),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_process_exit {
    pub ee: eventhandler_entry,
    pub eh_func: exitlist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_exit() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_process_exit>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_process_exit))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_process_exit>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_process_exit))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_process_exit>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_process_exit),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_process_exit>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_process_exit),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_process_fork {
    pub ee: eventhandler_entry,
    pub eh_func: forklist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_fork() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_process_fork>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_process_fork))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_process_fork>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_process_fork))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_process_fork>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_process_fork),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_process_fork>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_process_fork),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_process_exec {
    pub ee: eventhandler_entry,
    pub eh_func: execlist_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_process_exec() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_process_exec>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_process_exec))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_process_exec>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_process_exec))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_process_exec>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_process_exec),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_process_exec>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_process_exec),
            "::",
            stringify!(eh_func)
        )
    );
}
pub type app_coredump_start_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut thread, name: *mut cty::c_char),
>;
pub type app_coredump_progress_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut cty::c_void, td: *mut thread, byte_count: cty::c_int),
>;
pub type app_coredump_finish_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, td: *mut thread)>;
pub type app_coredump_error_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut cty::c_void, td: *mut thread, msg: *mut cty::c_char, ...),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_app_coredump_start {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_start_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_start() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_app_coredump_start>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(eventhandler_entry_app_coredump_start)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_app_coredump_start>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_app_coredump_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_app_coredump_start>())).ee as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_app_coredump_start),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_app_coredump_start>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_app_coredump_start),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_app_coredump_progress {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_progress_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_progress() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_app_coredump_progress>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(eventhandler_entry_app_coredump_progress)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_app_coredump_progress>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_app_coredump_progress)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_app_coredump_progress>())).ee as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_app_coredump_progress),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_app_coredump_progress>())).eh_func
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_app_coredump_progress),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_app_coredump_finish {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_finish_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_finish() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_app_coredump_finish>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(eventhandler_entry_app_coredump_finish)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_app_coredump_finish>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_app_coredump_finish)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_app_coredump_finish>())).ee as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_app_coredump_finish),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_app_coredump_finish>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_app_coredump_finish),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_app_coredump_error {
    pub ee: eventhandler_entry,
    pub eh_func: app_coredump_error_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_app_coredump_error() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_app_coredump_error>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(eventhandler_entry_app_coredump_error)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_app_coredump_error>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_app_coredump_error)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_app_coredump_error>())).ee as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_app_coredump_error),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_app_coredump_error>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_app_coredump_error),
            "::",
            stringify!(eh_func)
        )
    );
}
pub type thread_ctor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut thread)>;
pub type thread_dtor_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut thread)>;
pub type thread_fini_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut thread)>;
pub type thread_init_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut thread)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_thread_ctor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_ctor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_ctor() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_thread_ctor>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_thread_ctor))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_thread_ctor>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_thread_ctor))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_thread_ctor>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_thread_ctor),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_thread_ctor>())).eh_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_thread_ctor),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_thread_dtor {
    pub ee: eventhandler_entry,
    pub eh_func: thread_dtor_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_dtor() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_thread_dtor>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_thread_dtor))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_thread_dtor>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_thread_dtor))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_thread_dtor>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_thread_dtor),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_thread_dtor>())).eh_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_thread_dtor),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_thread_init {
    pub ee: eventhandler_entry,
    pub eh_func: thread_init_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_init() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_thread_init>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_thread_init))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_thread_init>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_thread_init))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_thread_init>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_thread_init),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_thread_init>())).eh_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_thread_init),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_thread_fini {
    pub ee: eventhandler_entry,
    pub eh_func: thread_fini_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_thread_fini() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_thread_fini>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_thread_fini))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_thread_fini>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_thread_fini))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_thread_fini>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_thread_fini),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_thread_fini>())).eh_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_thread_fini),
            "::",
            stringify!(eh_func)
        )
    );
}
pub type uma_zone_chfn = ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_nmbclusters_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_nmbclusters_change() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_nmbclusters_change>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(eventhandler_entry_nmbclusters_change)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_nmbclusters_change>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_nmbclusters_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_nmbclusters_change>())).ee as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_nmbclusters_change),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_nmbclusters_change>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_nmbclusters_change),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_nmbufs_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_nmbufs_change() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_nmbufs_change>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_nmbufs_change))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_nmbufs_change>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_nmbufs_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_nmbufs_change>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_nmbufs_change),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_nmbufs_change>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_nmbufs_change),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_maxsockets_change {
    pub ee: eventhandler_entry,
    pub eh_func: uma_zone_chfn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_maxsockets_change() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_maxsockets_change>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(eventhandler_entry_maxsockets_change)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_maxsockets_change>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_maxsockets_change)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_maxsockets_change>())).ee as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_maxsockets_change),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_maxsockets_change>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_maxsockets_change),
            "::",
            stringify!(eh_func)
        )
    );
}
pub type kld_load_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut linker_file)>;
pub type kld_unload_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut cty::c_void,
        arg2: *const cty::c_char,
        arg3: caddr_t,
        arg4: size_t,
    ),
>;
pub type kld_unload_try_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut linker_file, arg3: *mut cty::c_int),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_kld_load {
    pub ee: eventhandler_entry,
    pub eh_func: kld_load_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_load() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_kld_load>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_kld_load))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_kld_load>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_kld_load))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<eventhandler_entry_kld_load>())).ee as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_kld_load),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_kld_load>())).eh_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_kld_load),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_kld_unload {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_unload() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_kld_unload>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_kld_unload))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_kld_unload>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_kld_unload))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_kld_unload>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_kld_unload),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_kld_unload>())).eh_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_kld_unload),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_kld_unload_try {
    pub ee: eventhandler_entry,
    pub eh_func: kld_unload_try_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_kld_unload_try() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_kld_unload_try>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_kld_unload_try))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_kld_unload_try>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_kld_unload_try)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_kld_unload_try>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_kld_unload_try),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_kld_unload_try>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_kld_unload_try),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fb_info {
    _unused: [u8; 0],
}
pub type register_framebuffer_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut fb_info)>;
pub type unregister_framebuffer_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut fb_info)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_register_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: register_framebuffer_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_register_framebuffer() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_register_framebuffer>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(eventhandler_entry_register_framebuffer)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_register_framebuffer>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_register_framebuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_register_framebuffer>())).ee as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_register_framebuffer),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_register_framebuffer>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_register_framebuffer),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_unregister_framebuffer {
    pub ee: eventhandler_entry,
    pub eh_func: unregister_framebuffer_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_unregister_framebuffer() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_unregister_framebuffer>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(eventhandler_entry_unregister_framebuffer)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_unregister_framebuffer>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_unregister_framebuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_unregister_framebuffer>())).ee as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_unregister_framebuffer),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_unregister_framebuffer>())).eh_func
                as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_unregister_framebuffer),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cam_path {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ata_params {
    _unused: [u8; 0],
}
pub type ada_probe_veto_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut cty::c_void,
        arg2: *mut cam_path,
        arg3: *mut ata_params,
        arg4: *mut cty::c_int,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_ada_probe_veto {
    pub ee: eventhandler_entry,
    pub eh_func: ada_probe_veto_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_ada_probe_veto() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_ada_probe_veto>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_ada_probe_veto))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_ada_probe_veto>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_ada_probe_veto)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_ada_probe_veto>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_ada_probe_veto),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_ada_probe_veto>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_ada_probe_veto),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct swdevt {
    _unused: [u8; 0],
}
pub type swapon_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut swdevt)>;
pub type swapoff_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut swdevt)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_swapon {
    pub ee: eventhandler_entry,
    pub eh_func: swapon_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_swapon() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_swapon>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_swapon))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_swapon>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_swapon))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<eventhandler_entry_swapon>())).ee as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_swapon),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_swapon>())).eh_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_swapon),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_swapoff {
    pub ee: eventhandler_entry,
    pub eh_func: swapoff_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_swapoff() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_swapoff>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_swapoff))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_swapoff>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_swapoff))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<eventhandler_entry_swapoff>())).ee as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_swapoff),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_swapoff>())).eh_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_swapoff),
            "::",
            stringify!(eh_func)
        )
    );
}
pub const evhdev_detach_EVHDEV_DETACH_BEGIN: evhdev_detach = 0;
pub const evhdev_detach_EVHDEV_DETACH_COMPLETE: evhdev_detach = 1;
pub const evhdev_detach_EVHDEV_DETACH_FAILED: evhdev_detach = 2;
pub type evhdev_detach = cty::c_uint;
pub type device_attach_fn =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: device_t)>;
pub type device_detach_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: device_t, arg3: evhdev_detach),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_device_attach {
    pub ee: eventhandler_entry,
    pub eh_func: device_attach_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_device_attach() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_device_attach>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_device_attach))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_device_attach>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_device_attach)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_device_attach>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_device_attach),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_device_attach>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_device_attach),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_device_detach {
    pub ee: eventhandler_entry,
    pub eh_func: device_detach_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_device_detach() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_device_detach>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_device_detach))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_device_detach>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(eventhandler_entry_device_detach)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_device_detach>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_device_detach),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_device_detach>())).eh_func as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_device_detach),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ifaddr {
    _unused: [u8; 0],
}
pub type rt_addrmsg_fn = ::core::option::Option<
    unsafe extern "C" fn(arg1: *mut cty::c_void, arg2: *mut ifaddr, arg3: cty::c_int),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_rt_addrmsg {
    pub ee: eventhandler_entry,
    pub eh_func: rt_addrmsg_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_rt_addrmsg() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_rt_addrmsg>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_rt_addrmsg))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_rt_addrmsg>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_rt_addrmsg))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_rt_addrmsg>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_rt_addrmsg),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_rt_addrmsg>())).eh_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_rt_addrmsg),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct snapdata {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devfs_dirent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct file {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cdev {
    pub si_spare0: *mut cty::c_void,
    pub si_flags: u_int,
    pub si_atime: timespec,
    pub si_ctime: timespec,
    pub si_mtime: timespec,
    pub si_uid: uid_t,
    pub si_gid: gid_t,
    pub si_mode: mode_t,
    pub si_cred: *mut ucred,
    pub si_drv0: cty::c_int,
    pub si_refcount: cty::c_int,
    pub si_list: cdev__bindgen_ty_1,
    pub si_clone: cdev__bindgen_ty_2,
    pub si_children: cdev__bindgen_ty_3,
    pub si_siblings: cdev__bindgen_ty_4,
    pub si_parent: *mut cdev,
    pub si_mountpt: *mut mount,
    pub si_drv1: *mut cty::c_void,
    pub si_drv2: *mut cty::c_void,
    pub si_devsw: *mut cdevsw,
    pub si_iosize_max: cty::c_int,
    pub si_usecount: u_long,
    pub si_threadcount: u_long,
    pub __si_u: cdev__bindgen_ty_5,
    pub si_name: [cty::c_char; 64usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdev__bindgen_ty_1 {
    pub le_next: *mut cdev,
    pub le_prev: *mut *mut cdev,
}
#[test]
fn bindgen_test_layout_cdev__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<cdev__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(cdev__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<cdev__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cdev__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev__bindgen_ty_1>())).le_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev__bindgen_ty_1),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev__bindgen_ty_1>())).le_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev__bindgen_ty_1),
            "::",
            stringify!(le_prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdev__bindgen_ty_2 {
    pub le_next: *mut cdev,
    pub le_prev: *mut *mut cdev,
}
#[test]
fn bindgen_test_layout_cdev__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<cdev__bindgen_ty_2>(),
        16usize,
        concat!("Size of: ", stringify!(cdev__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<cdev__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(cdev__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev__bindgen_ty_2>())).le_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev__bindgen_ty_2),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev__bindgen_ty_2>())).le_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev__bindgen_ty_2),
            "::",
            stringify!(le_prev)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdev__bindgen_ty_3 {
    pub lh_first: *mut cdev,
}
#[test]
fn bindgen_test_layout_cdev__bindgen_ty_3() {
    assert_eq!(
        ::core::mem::size_of::<cdev__bindgen_ty_3>(),
        8usize,
        concat!("Size of: ", stringify!(cdev__bindgen_ty_3))
    );
    assert_eq!(
        ::core::mem::align_of::<cdev__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(cdev__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev__bindgen_ty_3>())).lh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev__bindgen_ty_3),
            "::",
            stringify!(lh_first)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdev__bindgen_ty_4 {
    pub le_next: *mut cdev,
    pub le_prev: *mut *mut cdev,
}
#[test]
fn bindgen_test_layout_cdev__bindgen_ty_4() {
    assert_eq!(
        ::core::mem::size_of::<cdev__bindgen_ty_4>(),
        16usize,
        concat!("Size of: ", stringify!(cdev__bindgen_ty_4))
    );
    assert_eq!(
        ::core::mem::align_of::<cdev__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(cdev__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev__bindgen_ty_4>())).le_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev__bindgen_ty_4),
            "::",
            stringify!(le_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev__bindgen_ty_4>())).le_prev as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev__bindgen_ty_4),
            "::",
            stringify!(le_prev)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cdev__bindgen_ty_5 {
    pub __sid_snapdata: *mut snapdata,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_cdev__bindgen_ty_5() {
    assert_eq!(
        ::core::mem::size_of::<cdev__bindgen_ty_5>(),
        8usize,
        concat!("Size of: ", stringify!(cdev__bindgen_ty_5))
    );
    assert_eq!(
        ::core::mem::align_of::<cdev__bindgen_ty_5>(),
        8usize,
        concat!("Alignment of ", stringify!(cdev__bindgen_ty_5))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cdev__bindgen_ty_5>())).__sid_snapdata as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev__bindgen_ty_5),
            "::",
            stringify!(__sid_snapdata)
        )
    );
}
#[test]
fn bindgen_test_layout_cdev() {
    assert_eq!(
        ::core::mem::size_of::<cdev>(),
        288usize,
        concat!("Size of: ", stringify!(cdev))
    );
    assert_eq!(
        ::core::mem::align_of::<cdev>(),
        8usize,
        concat!("Alignment of ", stringify!(cdev))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_spare0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_spare0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_atime as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_atime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_ctime as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_ctime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_mtime as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_mtime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_uid as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_gid as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_mode as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_cred as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_cred)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_drv0 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_drv0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_refcount as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_list as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_clone as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_clone)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_children as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_children)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_siblings as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_siblings)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_parent as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_parent)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_mountpt as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_mountpt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_drv1 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_drv1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_drv2 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_drv2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_devsw as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_devsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_iosize_max as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_iosize_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_usecount as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_usecount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_threadcount as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_threadcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).__si_u as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(__si_u)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdev>())).si_name as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cdev),
            "::",
            stringify!(si_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bio {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct buf {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kerneldumpheader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct knote {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct clonedevs {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vm_object {
    _unused: [u8; 0],
}
pub type d_open_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut cdev,
        oflags: cty::c_int,
        devtype: cty::c_int,
        td: *mut thread,
    ) -> cty::c_int,
>;
pub type d_fdopen_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut cdev,
        oflags: cty::c_int,
        td: *mut thread,
        fp: *mut file,
    ) -> cty::c_int,
>;
pub type d_close_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut cdev,
        fflag: cty::c_int,
        devtype: cty::c_int,
        td: *mut thread,
    ) -> cty::c_int,
>;
pub type d_strategy_t = ::core::option::Option<unsafe extern "C" fn(bp: *mut bio)>;
pub type d_ioctl_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut cdev,
        cmd: u_long,
        data: caddr_t,
        fflag: cty::c_int,
        td: *mut thread,
    ) -> cty::c_int,
>;
pub type d_read_t = ::core::option::Option<
    unsafe extern "C" fn(dev: *mut cdev, uio: *mut uio, ioflag: cty::c_int) -> cty::c_int,
>;
pub type d_write_t = ::core::option::Option<
    unsafe extern "C" fn(dev: *mut cdev, uio: *mut uio, ioflag: cty::c_int) -> cty::c_int,
>;
pub type d_poll_t = ::core::option::Option<
    unsafe extern "C" fn(dev: *mut cdev, events: cty::c_int, td: *mut thread) -> cty::c_int,
>;
pub type d_kqfilter_t =
    ::core::option::Option<unsafe extern "C" fn(dev: *mut cdev, kn: *mut knote) -> cty::c_int>;
pub type d_mmap_t = ::core::option::Option<
    unsafe extern "C" fn(
        dev: *mut cdev,
        offset: vm_ooffset_t,
        paddr: *mut vm_paddr_t,
        nprot: cty::c_int,
        memattr: *mut vm_memattr_t,
    ) -> cty::c_int,
>;
pub type d_mmap_single_t = ::core::option::Option<
    unsafe extern "C" fn(
        cdev: *mut cdev,
        offset: *mut vm_ooffset_t,
        size: vm_size_t,
        object: *mut *mut vm_object,
        nprot: cty::c_int,
    ) -> cty::c_int,
>;
pub type d_purge_t = ::core::option::Option<unsafe extern "C" fn(dev: *mut cdev)>;
pub type dumper_t = ::core::option::Option<
    unsafe extern "C" fn(
        _priv: *mut cty::c_void,
        _virtual: *mut cty::c_void,
        _physical: vm_offset_t,
        _offset: off_t,
        _length: size_t,
    ) -> cty::c_int,
>;
pub type dumper_start_t =
    ::core::option::Option<unsafe extern "C" fn(di: *mut dumperinfo) -> cty::c_int>;
pub type dumper_hdr_t = ::core::option::Option<
    unsafe extern "C" fn(
        di: *mut dumperinfo,
        kdh: *mut kerneldumpheader,
        key: *mut cty::c_void,
        keylen: u32,
    ) -> cty::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cdevsw {
    pub d_version: cty::c_int,
    pub d_flags: u_int,
    pub d_name: *const cty::c_char,
    pub d_open: d_open_t,
    pub d_fdopen: d_fdopen_t,
    pub d_close: d_close_t,
    pub d_read: d_read_t,
    pub d_write: d_write_t,
    pub d_ioctl: d_ioctl_t,
    pub d_poll: d_poll_t,
    pub d_mmap: d_mmap_t,
    pub d_strategy: d_strategy_t,
    pub d_dump: dumper_t,
    pub d_kqfilter: d_kqfilter_t,
    pub d_purge: d_purge_t,
    pub d_mmap_single: d_mmap_single_t,
    pub d_spare0: [i32; 3usize],
    pub d_spare1: [*mut cty::c_void; 3usize],
    pub d_devs: cdevsw__bindgen_ty_1,
    pub d_spare2: cty::c_int,
    pub __d_giant: cdevsw__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdevsw__bindgen_ty_1 {
    pub lh_first: *mut cdev,
}
#[test]
fn bindgen_test_layout_cdevsw__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<cdevsw__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(cdevsw__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<cdevsw__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(cdevsw__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw__bindgen_ty_1>())).lh_first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw__bindgen_ty_1),
            "::",
            stringify!(lh_first)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union cdevsw__bindgen_ty_2 {
    pub gianttrick: *mut cdevsw,
    pub postfree_list: cdevsw__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cdevsw__bindgen_ty_2__bindgen_ty_1 {
    pub sle_next: *mut cdevsw,
}
#[test]
fn bindgen_test_layout_cdevsw__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<cdevsw__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(cdevsw__bindgen_ty_2__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<cdevsw__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(cdevsw__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cdevsw__bindgen_ty_2__bindgen_ty_1>())).sle_next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(sle_next)
        )
    );
}
#[test]
fn bindgen_test_layout_cdevsw__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<cdevsw__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(cdevsw__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<cdevsw__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(cdevsw__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cdevsw__bindgen_ty_2>())).gianttrick as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw__bindgen_ty_2),
            "::",
            stringify!(gianttrick)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cdevsw__bindgen_ty_2>())).postfree_list as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw__bindgen_ty_2),
            "::",
            stringify!(postfree_list)
        )
    );
}
#[test]
fn bindgen_test_layout_cdevsw() {
    assert_eq!(
        ::core::mem::size_of::<cdevsw>(),
        184usize,
        concat!("Size of: ", stringify!(cdevsw))
    );
    assert_eq!(
        ::core::mem::align_of::<cdevsw>(),
        8usize,
        concat!("Alignment of ", stringify!(cdevsw))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_flags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_open as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_open)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_fdopen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_fdopen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_close as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_close)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_read as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_write as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_ioctl as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_ioctl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_poll as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_mmap as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_mmap)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_strategy as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_strategy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_dump as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_dump)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_kqfilter as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_kqfilter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_purge as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_purge)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_mmap_single as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_mmap_single)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_spare0 as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_spare0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_spare1 as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_spare1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_devs as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_devs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).d_spare2 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(d_spare2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cdevsw>())).__d_giant as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(cdevsw),
            "::",
            stringify!(__d_giant)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct devsw_module_data {
    pub chainevh: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut module,
            arg2: cty::c_int,
            arg3: *mut cty::c_void,
        ) -> cty::c_int,
    >,
    pub chainarg: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_devsw_module_data() {
    assert_eq!(
        ::core::mem::size_of::<devsw_module_data>(),
        16usize,
        concat!("Size of: ", stringify!(devsw_module_data))
    );
    assert_eq!(
        ::core::mem::align_of::<devsw_module_data>(),
        8usize,
        concat!("Alignment of ", stringify!(devsw_module_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<devsw_module_data>())).chainevh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(devsw_module_data),
            "::",
            stringify!(chainevh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<devsw_module_data>())).chainarg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(devsw_module_data),
            "::",
            stringify!(chainarg)
        )
    );
}
extern "C" {
    pub fn clone_setup(cdp: *mut *mut clonedevs);
}
extern "C" {
    pub fn clone_cleanup(arg1: *mut *mut clonedevs);
}
extern "C" {
    pub fn clone_create(
        arg1: *mut *mut clonedevs,
        arg2: *mut cdevsw,
        unit: *mut cty::c_int,
        dev: *mut *mut cdev,
        extra: cty::c_int,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct make_dev_args {
    pub mda_size: size_t,
    pub mda_flags: cty::c_int,
    pub mda_devsw: *mut cdevsw,
    pub mda_cr: *mut ucred,
    pub mda_uid: uid_t,
    pub mda_gid: gid_t,
    pub mda_mode: cty::c_int,
    pub mda_unit: cty::c_int,
    pub mda_si_drv1: *mut cty::c_void,
    pub mda_si_drv2: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_make_dev_args() {
    assert_eq!(
        ::core::mem::size_of::<make_dev_args>(),
        64usize,
        concat!("Size of: ", stringify!(make_dev_args))
    );
    assert_eq!(
        ::core::mem::align_of::<make_dev_args>(),
        8usize,
        concat!("Alignment of ", stringify!(make_dev_args))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<make_dev_args>())).mda_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(make_dev_args),
            "::",
            stringify!(mda_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<make_dev_args>())).mda_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(make_dev_args),
            "::",
            stringify!(mda_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<make_dev_args>())).mda_devsw as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(make_dev_args),
            "::",
            stringify!(mda_devsw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<make_dev_args>())).mda_cr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(make_dev_args),
            "::",
            stringify!(mda_cr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<make_dev_args>())).mda_uid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(make_dev_args),
            "::",
            stringify!(mda_uid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<make_dev_args>())).mda_gid as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(make_dev_args),
            "::",
            stringify!(mda_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<make_dev_args>())).mda_mode as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(make_dev_args),
            "::",
            stringify!(mda_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<make_dev_args>())).mda_unit as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(make_dev_args),
            "::",
            stringify!(mda_unit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<make_dev_args>())).mda_si_drv1 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(make_dev_args),
            "::",
            stringify!(mda_si_drv1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<make_dev_args>())).mda_si_drv2 as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(make_dev_args),
            "::",
            stringify!(mda_si_drv2)
        )
    );
}
extern "C" {
    pub fn make_dev_args_init_impl(_args: *mut make_dev_args, _sz: size_t);
}
extern "C" {
    pub fn count_dev(_dev: *mut cdev) -> cty::c_int;
}
extern "C" {
    pub fn delist_dev(_dev: *mut cdev);
}
extern "C" {
    pub fn destroy_dev(_dev: *mut cdev);
}
extern "C" {
    pub fn destroy_dev_sched(dev: *mut cdev) -> cty::c_int;
}
extern "C" {
    pub fn destroy_dev_sched_cb(
        dev: *mut cdev,
        cb: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>,
        arg: *mut cty::c_void,
    ) -> cty::c_int;
}
extern "C" {
    pub fn destroy_dev_drain(csw: *mut cdevsw);
}
extern "C" {
    pub fn drain_dev_clone_events();
}
extern "C" {
    pub fn dev_refthread(_dev: *mut cdev, _ref: *mut cty::c_int) -> *mut cdevsw;
}
extern "C" {
    pub fn devvn_refthread(
        vp: *mut vnode,
        devp: *mut *mut cdev,
        _ref: *mut cty::c_int,
    ) -> *mut cdevsw;
}
extern "C" {
    pub fn dev_relthread(_dev: *mut cdev, _ref: cty::c_int);
}
extern "C" {
    pub fn dev_depends(_pdev: *mut cdev, _cdev: *mut cdev);
}
extern "C" {
    pub fn dev_ref(dev: *mut cdev);
}
extern "C" {
    pub fn dev_refl(dev: *mut cdev);
}
extern "C" {
    pub fn dev_rel(dev: *mut cdev);
}
extern "C" {
    pub fn make_dev(
        _devsw: *mut cdevsw,
        _unit: cty::c_int,
        _uid: uid_t,
        _gid: gid_t,
        _perms: cty::c_int,
        _fmt: *const cty::c_char,
        ...
    ) -> *mut cdev;
}
extern "C" {
    pub fn make_dev_cred(
        _devsw: *mut cdevsw,
        _unit: cty::c_int,
        _cr: *mut ucred,
        _uid: uid_t,
        _gid: gid_t,
        _perms: cty::c_int,
        _fmt: *const cty::c_char,
        ...
    ) -> *mut cdev;
}
extern "C" {
    pub fn make_dev_credf(
        _flags: cty::c_int,
        _devsw: *mut cdevsw,
        _unit: cty::c_int,
        _cr: *mut ucred,
        _uid: uid_t,
        _gid: gid_t,
        _mode: cty::c_int,
        _fmt: *const cty::c_char,
        ...
    ) -> *mut cdev;
}
extern "C" {
    pub fn make_dev_p(
        _flags: cty::c_int,
        _cdev: *mut *mut cdev,
        _devsw: *mut cdevsw,
        _cr: *mut ucred,
        _uid: uid_t,
        _gid: gid_t,
        _mode: cty::c_int,
        _fmt: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn make_dev_s(
        _args: *mut make_dev_args,
        _cdev: *mut *mut cdev,
        _fmt: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn make_dev_alias(_pdev: *mut cdev, _fmt: *const cty::c_char, ...) -> *mut cdev;
}
extern "C" {
    pub fn make_dev_alias_p(
        _flags: cty::c_int,
        _cdev: *mut *mut cdev,
        _pdev: *mut cdev,
        _fmt: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn make_dev_physpath_alias(
        _flags: cty::c_int,
        _cdev: *mut *mut cdev,
        _pdev: *mut cdev,
        _old_alias: *mut cdev,
        _physpath: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn dev_lock();
}
extern "C" {
    pub fn dev_unlock();
}
pub type d_priv_dtor_t = ::core::option::Option<unsafe extern "C" fn(data: *mut cty::c_void)>;
extern "C" {
    pub fn devfs_get_cdevpriv(datap: *mut *mut cty::c_void) -> cty::c_int;
}
extern "C" {
    pub fn devfs_set_cdevpriv(priv_: *mut cty::c_void, dtr: d_priv_dtor_t) -> cty::c_int;
}
extern "C" {
    pub fn devfs_clear_cdevpriv();
}
extern "C" {
    pub fn devfs_alloc_cdp_inode() -> ino_t;
}
extern "C" {
    pub fn devfs_free_cdp_inode(ino: ino_t);
}
pub type dev_clone_fn = ::core::option::Option<
    unsafe extern "C" fn(
        arg: *mut cty::c_void,
        cred: *mut ucred,
        name: *mut cty::c_char,
        namelen: cty::c_int,
        result: *mut *mut cdev,
    ),
>;
extern "C" {
    pub fn dev_stdclone(
        _name: *mut cty::c_char,
        _namep: *mut *mut cty::c_char,
        _stem: *const cty::c_char,
        _unit: *mut cty::c_int,
    ) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct eventhandler_entry_dev_clone {
    pub ee: eventhandler_entry,
    pub eh_func: dev_clone_fn,
}
#[test]
fn bindgen_test_layout_eventhandler_entry_dev_clone() {
    assert_eq!(
        ::core::mem::size_of::<eventhandler_entry_dev_clone>(),
        40usize,
        concat!("Size of: ", stringify!(eventhandler_entry_dev_clone))
    );
    assert_eq!(
        ::core::mem::align_of::<eventhandler_entry_dev_clone>(),
        8usize,
        concat!("Alignment of ", stringify!(eventhandler_entry_dev_clone))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_dev_clone>())).ee as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_dev_clone),
            "::",
            stringify!(ee)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<eventhandler_entry_dev_clone>())).eh_func as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(eventhandler_entry_dev_clone),
            "::",
            stringify!(eh_func)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kerneldumpcrypto {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct dumperinfo {
    pub dumper: dumper_t,
    pub dumper_start: dumper_start_t,
    pub dumper_hdr: dumper_hdr_t,
    pub priv_: *mut cty::c_void,
    pub blocksize: u_int,
    pub maxiosize: u_int,
    pub mediaoffset: off_t,
    pub mediasize: off_t,
    pub blockbuf: *mut cty::c_void,
    pub dumpoff: off_t,
    pub origdumpoff: off_t,
    pub kdcrypto: *mut kerneldumpcrypto,
    pub kdcomp: *mut kerneldumpcomp,
}
#[test]
fn bindgen_test_layout_dumperinfo() {
    assert_eq!(
        ::core::mem::size_of::<dumperinfo>(),
        96usize,
        concat!("Size of: ", stringify!(dumperinfo))
    );
    assert_eq!(
        ::core::mem::align_of::<dumperinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(dumperinfo))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dumperinfo>())).dumper as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dumperinfo),
            "::",
            stringify!(dumper)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dumperinfo>())).dumper_start as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dumperinfo),
            "::",
            stringify!(dumper_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dumperinfo>())).dumper_hdr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(dumperinfo),
            "::",
            stringify!(dumper_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dumperinfo>())).priv_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(dumperinfo),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dumperinfo>())).blocksize as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dumperinfo),
            "::",
            stringify!(blocksize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dumperinfo>())).maxiosize as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(dumperinfo),
            "::",
            stringify!(maxiosize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dumperinfo>())).mediaoffset as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(dumperinfo),
            "::",
            stringify!(mediaoffset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dumperinfo>())).mediasize as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(dumperinfo),
            "::",
            stringify!(mediasize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dumperinfo>())).blockbuf as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dumperinfo),
            "::",
            stringify!(blockbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dumperinfo>())).dumpoff as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(dumperinfo),
            "::",
            stringify!(dumpoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dumperinfo>())).origdumpoff as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(dumperinfo),
            "::",
            stringify!(origdumpoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dumperinfo>())).kdcrypto as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dumperinfo),
            "::",
            stringify!(kdcrypto)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dumperinfo>())).kdcomp as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(dumperinfo),
            "::",
            stringify!(kdcomp)
        )
    );
}
extern "C" {
    pub static mut dumping: cty::c_int;
}
extern "C" {
    pub fn doadump(arg1: boolean_t) -> cty::c_int;
}
extern "C" {
    pub fn set_dumper(
        di: *mut dumperinfo,
        devname: *const cty::c_char,
        td: *mut thread,
        compression: u8,
        encryption: u8,
        key: *const u8,
        encryptedkeysize: u32,
        encryptedkey: *const u8,
    ) -> cty::c_int;
}
extern "C" {
    pub fn clear_dumper(td: *mut thread) -> cty::c_int;
}
extern "C" {
    pub fn dump_start(di: *mut dumperinfo, kdh: *mut kerneldumpheader) -> cty::c_int;
}
extern "C" {
    pub fn dump_append(
        arg1: *mut dumperinfo,
        arg2: *mut cty::c_void,
        arg3: vm_offset_t,
        arg4: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn dump_write(
        arg1: *mut dumperinfo,
        arg2: *mut cty::c_void,
        arg3: vm_offset_t,
        arg4: off_t,
        arg5: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn dump_finish(di: *mut dumperinfo, kdh: *mut kerneldumpheader) -> cty::c_int;
}
extern "C" {
    pub fn dump_init_header(
        di: *const dumperinfo,
        kdh: *mut kerneldumpheader,
        magic: *mut cty::c_char,
        archver: u32,
        dumplen: u64,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct iovec {
    pub iov_base: *mut cty::c_void,
    pub iov_len: size_t,
}
#[test]
fn bindgen_test_layout_iovec() {
    assert_eq!(
        ::core::mem::size_of::<iovec>(),
        16usize,
        concat!("Size of: ", stringify!(iovec))
    );
    assert_eq!(
        ::core::mem::align_of::<iovec>(),
        8usize,
        concat!("Alignment of ", stringify!(iovec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iovec>())).iov_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<iovec>())).iov_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(iovec),
            "::",
            stringify!(iov_len)
        )
    );
}
pub const uio_rw_UIO_READ: uio_rw = 0;
pub const uio_rw_UIO_WRITE: uio_rw = 1;
pub type uio_rw = cty::c_uint;
pub const uio_seg_UIO_USERSPACE: uio_seg = 0;
pub const uio_seg_UIO_SYSSPACE: uio_seg = 1;
pub const uio_seg_UIO_NOCOPY: uio_seg = 2;
pub type uio_seg = cty::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uio {
    pub uio_iov: *mut iovec,
    pub uio_iovcnt: cty::c_int,
    pub uio_offset: off_t,
    pub uio_resid: ssize_t,
    pub uio_segflg: uio_seg,
    pub uio_rw: uio_rw,
    pub uio_td: *mut thread,
}
#[test]
fn bindgen_test_layout_uio() {
    assert_eq!(
        ::core::mem::size_of::<uio>(),
        48usize,
        concat!("Size of: ", stringify!(uio))
    );
    assert_eq!(
        ::core::mem::align_of::<uio>(),
        8usize,
        concat!("Alignment of ", stringify!(uio))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uio>())).uio_iov as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uio),
            "::",
            stringify!(uio_iov)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uio>())).uio_iovcnt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uio),
            "::",
            stringify!(uio_iovcnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uio>())).uio_offset as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uio),
            "::",
            stringify!(uio_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uio>())).uio_resid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uio),
            "::",
            stringify!(uio_resid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uio>())).uio_segflg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uio),
            "::",
            stringify!(uio_segflg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uio>())).uio_rw as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(uio),
            "::",
            stringify!(uio_rw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<uio>())).uio_td as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uio),
            "::",
            stringify!(uio_td)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bus_dma_segment {
    _unused: [u8; 0],
}
extern "C" {
    pub fn cloneuio(uiop: *mut uio) -> *mut uio;
}
extern "C" {
    pub fn copyinfrom(
        src: *const cty::c_void,
        dst: *mut cty::c_void,
        len: size_t,
        seg: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn copyiniov(
        iovp: *const iovec,
        iovcnt: u_int,
        iov: *mut *mut iovec,
        error: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn copyinstrfrom(
        src: *const cty::c_void,
        dst: *mut cty::c_void,
        len: size_t,
        copied: *mut size_t,
        seg: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn copyinuio(iovp: *const iovec, iovcnt: u_int, uiop: *mut *mut uio) -> cty::c_int;
}
extern "C" {
    pub fn copyout_map(td: *mut thread, addr: *mut vm_offset_t, sz: size_t) -> cty::c_int;
}
extern "C" {
    pub fn copyout_unmap(td: *mut thread, addr: vm_offset_t, sz: size_t) -> cty::c_int;
}
extern "C" {
    pub fn physcopyin(src: *mut cty::c_void, dst: vm_paddr_t, len: size_t) -> cty::c_int;
}
extern "C" {
    pub fn physcopyout(src: vm_paddr_t, dst: *mut cty::c_void, len: size_t) -> cty::c_int;
}
extern "C" {
    pub fn physcopyin_vlist(
        src: *mut bus_dma_segment,
        offset: off_t,
        dst: vm_paddr_t,
        len: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn physcopyout_vlist(
        src: vm_paddr_t,
        dst: *mut bus_dma_segment,
        offset: off_t,
        len: size_t,
    ) -> cty::c_int;
}
extern "C" {
    pub fn uiomove(cp: *mut cty::c_void, n: cty::c_int, uio: *mut uio) -> cty::c_int;
}
extern "C" {
    pub fn uiomove_frombuf(buf: *mut cty::c_void, buflen: cty::c_int, uio: *mut uio) -> cty::c_int;
}
extern "C" {
    pub fn uiomove_fromphys(
        ma: *mut *mut vm_page,
        offset: vm_offset_t,
        n: cty::c_int,
        uio: *mut uio,
    ) -> cty::c_int;
}
extern "C" {
    pub fn uiomove_nofault(cp: *mut cty::c_void, n: cty::c_int, uio: *mut uio) -> cty::c_int;
}
extern "C" {
    pub fn uiomove_object(obj: *mut vm_object, obj_size: off_t, uio: *mut uio) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_type_stats {
    pub mts_memalloced: u64,
    pub mts_memfreed: u64,
    pub mts_numallocs: u64,
    pub mts_numfrees: u64,
    pub mts_size: u64,
    pub _mts_reserved1: u64,
    pub _mts_reserved2: u64,
    pub _mts_reserved3: u64,
}
#[test]
fn bindgen_test_layout_malloc_type_stats() {
    assert_eq!(
        ::core::mem::size_of::<malloc_type_stats>(),
        64usize,
        concat!("Size of: ", stringify!(malloc_type_stats))
    );
    assert_eq!(
        ::core::mem::align_of::<malloc_type_stats>(),
        8usize,
        concat!("Alignment of ", stringify!(malloc_type_stats))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<malloc_type_stats>())).mts_memalloced as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stats),
            "::",
            stringify!(mts_memalloced)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_type_stats>())).mts_memfreed as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stats),
            "::",
            stringify!(mts_memfreed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<malloc_type_stats>())).mts_numallocs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stats),
            "::",
            stringify!(mts_numallocs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_type_stats>())).mts_numfrees as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stats),
            "::",
            stringify!(mts_numfrees)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_type_stats>())).mts_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stats),
            "::",
            stringify!(mts_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<malloc_type_stats>()))._mts_reserved1 as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stats),
            "::",
            stringify!(_mts_reserved1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<malloc_type_stats>()))._mts_reserved2 as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stats),
            "::",
            stringify!(_mts_reserved2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<malloc_type_stats>()))._mts_reserved3 as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stats),
            "::",
            stringify!(_mts_reserved3)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_type_internal {
    pub mti_probes: [u32; 2usize],
    pub mti_zone: u_char,
    pub mti_stats: *mut malloc_type_stats,
}
#[test]
fn bindgen_test_layout_malloc_type_internal() {
    assert_eq!(
        ::core::mem::size_of::<malloc_type_internal>(),
        24usize,
        concat!("Size of: ", stringify!(malloc_type_internal))
    );
    assert_eq!(
        ::core::mem::align_of::<malloc_type_internal>(),
        8usize,
        concat!("Alignment of ", stringify!(malloc_type_internal))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<malloc_type_internal>())).mti_probes as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_internal),
            "::",
            stringify!(mti_probes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_type_internal>())).mti_zone as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_internal),
            "::",
            stringify!(mti_zone)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_type_internal>())).mti_stats as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_internal),
            "::",
            stringify!(mti_stats)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_type {
    pub ks_next: *mut malloc_type,
    pub ks_magic: u_long,
    pub ks_shortdesc: *const cty::c_char,
    pub ks_handle: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout_malloc_type() {
    assert_eq!(
        ::core::mem::size_of::<malloc_type>(),
        32usize,
        concat!("Size of: ", stringify!(malloc_type))
    );
    assert_eq!(
        ::core::mem::align_of::<malloc_type>(),
        8usize,
        concat!("Alignment of ", stringify!(malloc_type))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_type>())).ks_next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type),
            "::",
            stringify!(ks_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_type>())).ks_magic as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type),
            "::",
            stringify!(ks_magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_type>())).ks_shortdesc as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type),
            "::",
            stringify!(ks_shortdesc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_type>())).ks_handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type),
            "::",
            stringify!(ks_handle)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_type_stream_header {
    pub mtsh_version: u32,
    pub mtsh_maxcpus: u32,
    pub mtsh_count: u32,
    pub _mtsh_pad: u32,
}
#[test]
fn bindgen_test_layout_malloc_type_stream_header() {
    assert_eq!(
        ::core::mem::size_of::<malloc_type_stream_header>(),
        16usize,
        concat!("Size of: ", stringify!(malloc_type_stream_header))
    );
    assert_eq!(
        ::core::mem::align_of::<malloc_type_stream_header>(),
        4usize,
        concat!("Alignment of ", stringify!(malloc_type_stream_header))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<malloc_type_stream_header>())).mtsh_version as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stream_header),
            "::",
            stringify!(mtsh_version)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<malloc_type_stream_header>())).mtsh_maxcpus as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stream_header),
            "::",
            stringify!(mtsh_maxcpus)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<malloc_type_stream_header>())).mtsh_count as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stream_header),
            "::",
            stringify!(mtsh_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<malloc_type_stream_header>()))._mtsh_pad as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_stream_header),
            "::",
            stringify!(_mtsh_pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct malloc_type_header {
    pub mth_name: [cty::c_char; 32usize],
}
#[test]
fn bindgen_test_layout_malloc_type_header() {
    assert_eq!(
        ::core::mem::size_of::<malloc_type_header>(),
        32usize,
        concat!("Size of: ", stringify!(malloc_type_header))
    );
    assert_eq!(
        ::core::mem::align_of::<malloc_type_header>(),
        1usize,
        concat!("Alignment of ", stringify!(malloc_type_header))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<malloc_type_header>())).mth_name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(malloc_type_header),
            "::",
            stringify!(mth_name)
        )
    );
}
extern "C" {
    pub static mut M_CACHE: [malloc_type; 1usize];
}
extern "C" {
    pub static mut M_DEVBUF: [malloc_type; 1usize];
}
extern "C" {
    pub static mut M_TEMP: [malloc_type; 1usize];
}
extern "C" {
    pub static mut M_IOV: [malloc_type; 1usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct domainset {
    _unused: [u8; 0],
}
extern "C" {
    pub static mut malloc_mtx: mtx;
}
pub type malloc_type_list_func_t =
    ::core::option::Option<unsafe extern "C" fn(arg1: *mut malloc_type, arg2: *mut cty::c_void)>;
extern "C" {
    pub fn contigfree(addr: *mut cty::c_void, size: cty::c_ulong, type_: *mut malloc_type);
}
extern "C" {
    pub fn contigmalloc(
        size: cty::c_ulong,
        type_: *mut malloc_type,
        flags: cty::c_int,
        low: vm_paddr_t,
        high: vm_paddr_t,
        alignment: cty::c_ulong,
        boundary: vm_paddr_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn contigmalloc_domainset(
        size: cty::c_ulong,
        type_: *mut malloc_type,
        ds: *mut domainset,
        flags: cty::c_int,
        low: vm_paddr_t,
        high: vm_paddr_t,
        alignment: cty::c_ulong,
        boundary: vm_paddr_t,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn free(addr: *mut cty::c_void, type_: *mut malloc_type);
}
extern "C" {
    pub fn free_domain(addr: *mut cty::c_void, type_: *mut malloc_type);
}
extern "C" {
    pub fn malloc(size: size_t, type_: *mut malloc_type, flags: cty::c_int) -> *mut cty::c_void;
}
extern "C" {
    pub fn malloc_domainset(
        size: size_t,
        type_: *mut malloc_type,
        ds: *mut domainset,
        flags: cty::c_int,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn mallocarray(
        nmemb: size_t,
        size: size_t,
        type_: *mut malloc_type,
        flags: cty::c_int,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn malloc_init(arg1: *mut cty::c_void);
}
extern "C" {
    pub fn malloc_last_fail() -> cty::c_int;
}
extern "C" {
    pub fn malloc_type_allocated(type_: *mut malloc_type, size: cty::c_ulong);
}
extern "C" {
    pub fn malloc_type_freed(type_: *mut malloc_type, size: cty::c_ulong);
}
extern "C" {
    pub fn malloc_type_list(arg1: malloc_type_list_func_t, arg2: *mut cty::c_void);
}
extern "C" {
    pub fn malloc_uninit(arg1: *mut cty::c_void);
}
extern "C" {
    pub fn malloc_usable_size(arg1: *const cty::c_void) -> size_t;
}
extern "C" {
    pub fn realloc(
        addr: *mut cty::c_void,
        size: size_t,
        type_: *mut malloc_type,
        flags: cty::c_int,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn reallocf(
        addr: *mut cty::c_void,
        size: size_t,
        type_: *mut malloc_type,
        flags: cty::c_int,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn malloc_desc2type(desc: *const cty::c_char) -> *mut malloc_type;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kproc_desc {
    pub arg0: *const cty::c_char,
    pub func: ::core::option::Option<unsafe extern "C" fn()>,
    pub global_procpp: *mut *mut proc_,
}
#[test]
fn bindgen_test_layout_kproc_desc() {
    assert_eq!(
        ::core::mem::size_of::<kproc_desc>(),
        24usize,
        concat!("Size of: ", stringify!(kproc_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<kproc_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(kproc_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kproc_desc>())).arg0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kproc_desc),
            "::",
            stringify!(arg0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kproc_desc>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kproc_desc),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kproc_desc>())).global_procpp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kproc_desc),
            "::",
            stringify!(global_procpp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kthread_desc {
    pub arg0: *const cty::c_char,
    pub func: ::core::option::Option<unsafe extern "C" fn()>,
    pub global_threadpp: *mut *mut thread,
}
#[test]
fn bindgen_test_layout_kthread_desc() {
    assert_eq!(
        ::core::mem::size_of::<kthread_desc>(),
        24usize,
        concat!("Size of: ", stringify!(kthread_desc))
    );
    assert_eq!(
        ::core::mem::align_of::<kthread_desc>(),
        8usize,
        concat!("Alignment of ", stringify!(kthread_desc))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kthread_desc>())).arg0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(kthread_desc),
            "::",
            stringify!(arg0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kthread_desc>())).func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(kthread_desc),
            "::",
            stringify!(func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<kthread_desc>())).global_threadpp as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(kthread_desc),
            "::",
            stringify!(global_threadpp)
        )
    );
}
extern "C" {
    pub fn kproc_create(
        arg1: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>,
        arg2: *mut cty::c_void,
        arg3: *mut *mut proc_,
        flags: cty::c_int,
        pages: cty::c_int,
        arg4: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn kproc_exit(arg1: cty::c_int);
}
extern "C" {
    pub fn kproc_resume(arg1: *mut proc_) -> cty::c_int;
}
extern "C" {
    pub fn kproc_shutdown(arg1: *mut cty::c_void, arg2: cty::c_int);
}
extern "C" {
    pub fn kproc_start(arg1: *const cty::c_void);
}
extern "C" {
    pub fn kproc_suspend(arg1: *mut proc_, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn kproc_suspend_check(arg1: *mut proc_);
}
extern "C" {
    pub fn kproc_kthread_add(
        arg1: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>,
        arg2: *mut cty::c_void,
        arg3: *mut *mut proc_,
        arg4: *mut *mut thread,
        flags: cty::c_int,
        pages: cty::c_int,
        procname: *const cty::c_char,
        arg5: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn kthread_add(
        arg1: ::core::option::Option<unsafe extern "C" fn(arg1: *mut cty::c_void)>,
        arg2: *mut cty::c_void,
        arg3: *mut proc_,
        arg4: *mut *mut thread,
        flags: cty::c_int,
        pages: cty::c_int,
        arg5: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn kthread_exit();
}
extern "C" {
    pub fn kthread_resume(arg1: *mut thread) -> cty::c_int;
}
extern "C" {
    pub fn kthread_shutdown(arg1: *mut cty::c_void, arg2: cty::c_int);
}
extern "C" {
    pub fn kthread_start(arg1: *const cty::c_void);
}
extern "C" {
    pub fn kthread_suspend(arg1: *mut thread, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn kthread_suspend_check();
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: cty::c_uint,
    pub fp_offset: cty::c_uint,
    pub overflow_arg_area: *mut cty::c_void,
    pub reg_save_area: *mut cty::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct witness {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pcb {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pmap {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct amd64tss {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct user_segment_descriptor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct system_segment_descriptor {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct kerneldumpcomp {
    pub _address: u8,
}
